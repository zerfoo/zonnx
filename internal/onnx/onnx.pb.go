//
// WARNING: This file is automatically generated!  Please edit onnx.in.proto.
//

// SPDX-License-Identifier: Apache-2.0

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v6.32.0
// source: zonnx/internal/onnx/onnx.proto

package onnx

import (
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"

	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Versioning
//
// ONNX versioning is specified in docs/IR.md and elaborated on in docs/Versioning.md
//
// To be compatible with both proto2 and proto3, we will use a version number
// that is not defined by the default value but an explicit enum number.
type Version int32

const (
	// proto3 requires the first enum value to be zero.
	// We add this just to appease the compiler.
	Version__START_VERSION Version = 0
	// The version field is always serialized and we will use it to store the
	// version that the  graph is generated from. This helps us set up version
	// control.
	// For the IR, we are using simple numbers starting with 0x00000001,
	// which was the version we published on Oct 10, 2017.
	Version_IR_VERSION_2017_10_10 Version = 1
	// IR_VERSION 2 published on Oct 30, 2017
	// - Added type discriminator to AttributeProto to support proto3 users
	Version_IR_VERSION_2017_10_30 Version = 2
	// IR VERSION 3 published on Nov 3, 2017
	// - For operator versioning:
	//   - Added new message OperatorSetIdProto
	//   - Added opset_import in ModelProto
	//
	// - For vendor extensions, added domain in NodeProto
	Version_IR_VERSION_2017_11_3 Version = 3
	// IR VERSION 4 published on Jan 22, 2019
	// - Relax constraint that initializers should be a subset of graph inputs
	// - Add type BFLOAT16
	Version_IR_VERSION_2019_1_22 Version = 4
	// IR VERSION 5 published on March 18, 2019
	// - Add message TensorAnnotation.
	// - Add quantization annotation in GraphProto to map tensor with its scale and zero point quantization parameters.
	Version_IR_VERSION_2019_3_18 Version = 5
	// IR VERSION 6 published on Sep 19, 2019
	// - Add support for sparse tensor constants stored in model.
	//   - Add message SparseTensorProto
	//   - Add sparse initializers
	Version_IR_VERSION_2019_9_19 Version = 6
	// IR VERSION 7 published on May 8, 2020
	//   - Add support to allow function body graph to rely on multiple external operator sets.
	//   - Add a list to promote inference graph's initializers to global and
	//     mutable variables. Global variables are visible in all graphs of the
	//     stored models.
	//   - Add message TrainingInfoProto to store initialization
	//     method and training algorithm. The execution of TrainingInfoProto
	//     can modify the values of mutable variables.
	//   - Implicitly add inference graph into each TrainingInfoProto's algorithm.
	Version_IR_VERSION_2020_5_8 Version = 7
	// IR VERSION 8 published on July 30, 2021
	// Introduce TypeProto.SparseTensor
	// Introduce TypeProto.Optional
	// Added a list of FunctionProtos local to the model
	// Deprecated since_version and operator status from FunctionProto
	Version_IR_VERSION_2021_7_30 Version = 8
	// IR VERSION 9 published on May 5, 2023
	// Added AttributeProto to FunctionProto so that default attribute values can be set.
	// Added FLOAT8E4M3FN, FLOAT8E4M3FNUZ, FLOAT8E5M2, FLOAT8E5M2FNUZ.
	Version_IR_VERSION_2023_5_5 Version = 9
	// IR VERSION 10 published on March 25, 2024
	// Added UINT4, INT4, overload field for functions and metadata_props on multiple proto definitions.
	Version_IR_VERSION_2024_3_25 Version = 10
	// IR VERSION 11 published on May 12, 2025
	// Added FLOAT4E2M1, multi-device protobuf classes.
	Version_IR_VERSION_2025_05_12 Version = 11
	// IR VERSION 12 published on TBD
	// Added FLOAT8E8M0.
	Version_IR_VERSION Version = 12
)

// Enum value maps for Version.
var (
	Version_name = map[int32]string{
		0:  "_START_VERSION",
		1:  "IR_VERSION_2017_10_10",
		2:  "IR_VERSION_2017_10_30",
		3:  "IR_VERSION_2017_11_3",
		4:  "IR_VERSION_2019_1_22",
		5:  "IR_VERSION_2019_3_18",
		6:  "IR_VERSION_2019_9_19",
		7:  "IR_VERSION_2020_5_8",
		8:  "IR_VERSION_2021_7_30",
		9:  "IR_VERSION_2023_5_5",
		10: "IR_VERSION_2024_3_25",
		11: "IR_VERSION_2025_05_12",
		12: "IR_VERSION",
	}
	Version_value = map[string]int32{
		"_START_VERSION":        0,
		"IR_VERSION_2017_10_10": 1,
		"IR_VERSION_2017_10_30": 2,
		"IR_VERSION_2017_11_3":  3,
		"IR_VERSION_2019_1_22":  4,
		"IR_VERSION_2019_3_18":  5,
		"IR_VERSION_2019_9_19":  6,
		"IR_VERSION_2020_5_8":   7,
		"IR_VERSION_2021_7_30":  8,
		"IR_VERSION_2023_5_5":   9,
		"IR_VERSION_2024_3_25":  10,
		"IR_VERSION_2025_05_12": 11,
		"IR_VERSION":            12,
	}
)

func (x Version) Enum() *Version {
	p := new(Version)
	*p = x
	return p
}

func (x Version) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Version) Descriptor() protoreflect.EnumDescriptor {
	return file_zonnx_internal_onnx_onnx_proto_enumTypes[0].Descriptor()
}

func (Version) Type() protoreflect.EnumType {
	return &file_zonnx_internal_onnx_onnx_proto_enumTypes[0]
}

func (x Version) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *Version) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = Version(num)
	return nil
}

// Deprecated: Use Version.Descriptor instead.
func (Version) EnumDescriptor() ([]byte, []int) {
	return file_zonnx_internal_onnx_onnx_proto_rawDescGZIP(), []int{0}
}

// Operator/function status.
type OperatorStatus int32

const (
	OperatorStatus_EXPERIMENTAL OperatorStatus = 0
	OperatorStatus_STABLE       OperatorStatus = 1
)

// Enum value maps for OperatorStatus.
var (
	OperatorStatus_name = map[int32]string{
		0: "EXPERIMENTAL",
		1: "STABLE",
	}
	OperatorStatus_value = map[string]int32{
		"EXPERIMENTAL": 0,
		"STABLE":       1,
	}
)

func (x OperatorStatus) Enum() *OperatorStatus {
	p := new(OperatorStatus)
	*p = x
	return p
}

func (x OperatorStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (OperatorStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_zonnx_internal_onnx_onnx_proto_enumTypes[1].Descriptor()
}

func (OperatorStatus) Type() protoreflect.EnumType {
	return &file_zonnx_internal_onnx_onnx_proto_enumTypes[1]
}

func (x OperatorStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *OperatorStatus) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = OperatorStatus(num)
	return nil
}

// Deprecated: Use OperatorStatus.Descriptor instead.
func (OperatorStatus) EnumDescriptor() ([]byte, []int) {
	return file_zonnx_internal_onnx_onnx_proto_rawDescGZIP(), []int{1}
}

// Note: this enum is structurally identical to the OpSchema::AttrType
// enum defined in schema.h.  If you rev one, you likely need to rev the other.
type AttributeProto_AttributeType int32

const (
	AttributeProto_UNDEFINED      AttributeProto_AttributeType = 0
	AttributeProto_FLOAT          AttributeProto_AttributeType = 1
	AttributeProto_INT            AttributeProto_AttributeType = 2
	AttributeProto_STRING         AttributeProto_AttributeType = 3
	AttributeProto_TENSOR         AttributeProto_AttributeType = 4
	AttributeProto_GRAPH          AttributeProto_AttributeType = 5
	AttributeProto_SPARSE_TENSOR  AttributeProto_AttributeType = 11
	AttributeProto_TYPE_PROTO     AttributeProto_AttributeType = 13
	AttributeProto_FLOATS         AttributeProto_AttributeType = 6
	AttributeProto_INTS           AttributeProto_AttributeType = 7
	AttributeProto_STRINGS        AttributeProto_AttributeType = 8
	AttributeProto_TENSORS        AttributeProto_AttributeType = 9
	AttributeProto_GRAPHS         AttributeProto_AttributeType = 10
	AttributeProto_SPARSE_TENSORS AttributeProto_AttributeType = 12
	AttributeProto_TYPE_PROTOS    AttributeProto_AttributeType = 14
)

// Enum value maps for AttributeProto_AttributeType.
var (
	AttributeProto_AttributeType_name = map[int32]string{
		0:  "UNDEFINED",
		1:  "FLOAT",
		2:  "INT",
		3:  "STRING",
		4:  "TENSOR",
		5:  "GRAPH",
		11: "SPARSE_TENSOR",
		13: "TYPE_PROTO",
		6:  "FLOATS",
		7:  "INTS",
		8:  "STRINGS",
		9:  "TENSORS",
		10: "GRAPHS",
		12: "SPARSE_TENSORS",
		14: "TYPE_PROTOS",
	}
	AttributeProto_AttributeType_value = map[string]int32{
		"UNDEFINED":      0,
		"FLOAT":          1,
		"INT":            2,
		"STRING":         3,
		"TENSOR":         4,
		"GRAPH":          5,
		"SPARSE_TENSOR":  11,
		"TYPE_PROTO":     13,
		"FLOATS":         6,
		"INTS":           7,
		"STRINGS":        8,
		"TENSORS":        9,
		"GRAPHS":         10,
		"SPARSE_TENSORS": 12,
		"TYPE_PROTOS":    14,
	}
)

func (x AttributeProto_AttributeType) Enum() *AttributeProto_AttributeType {
	p := new(AttributeProto_AttributeType)
	*p = x
	return p
}

func (x AttributeProto_AttributeType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (AttributeProto_AttributeType) Descriptor() protoreflect.EnumDescriptor {
	return file_zonnx_internal_onnx_onnx_proto_enumTypes[2].Descriptor()
}

func (AttributeProto_AttributeType) Type() protoreflect.EnumType {
	return &file_zonnx_internal_onnx_onnx_proto_enumTypes[2]
}

func (x AttributeProto_AttributeType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *AttributeProto_AttributeType) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = AttributeProto_AttributeType(num)
	return nil
}

// Deprecated: Use AttributeProto_AttributeType.Descriptor instead.
func (AttributeProto_AttributeType) EnumDescriptor() ([]byte, []int) {
	return file_zonnx_internal_onnx_onnx_proto_rawDescGZIP(), []int{0, 0}
}

type TensorProto_DataType int32

const (
	TensorProto_UNDEFINED TensorProto_DataType = 0
	// Basic types.
	TensorProto_FLOAT  TensorProto_DataType = 1 // float
	TensorProto_UINT8  TensorProto_DataType = 2 // uint8_t
	TensorProto_INT8   TensorProto_DataType = 3 // int8_t
	TensorProto_UINT16 TensorProto_DataType = 4 // uint16_t
	TensorProto_INT16  TensorProto_DataType = 5 // int16_t
	TensorProto_INT32  TensorProto_DataType = 6 // int32_t
	TensorProto_INT64  TensorProto_DataType = 7 // int64_t
	TensorProto_STRING TensorProto_DataType = 8 // string
	TensorProto_BOOL   TensorProto_DataType = 9 // bool
	// IEEE754 half-precision floating-point format (16 bits wide).
	// This format has 1 sign bit, 5 exponent bits, and 10 mantissa bits.
	TensorProto_FLOAT16    TensorProto_DataType = 10
	TensorProto_DOUBLE     TensorProto_DataType = 11
	TensorProto_UINT32     TensorProto_DataType = 12
	TensorProto_UINT64     TensorProto_DataType = 13
	TensorProto_COMPLEX64  TensorProto_DataType = 14 // complex with float32 real and imaginary components
	TensorProto_COMPLEX128 TensorProto_DataType = 15 // complex with float64 real and imaginary components
	// Non-IEEE floating-point format based on IEEE754 single-precision
	// floating-point number truncated to 16 bits.
	// This format has 1 sign bit, 8 exponent bits, and 7 mantissa bits.
	TensorProto_BFLOAT16 TensorProto_DataType = 16
	// Non-IEEE floating-point format based on papers
	// FP8 Formats for Deep Learning, https://arxiv.org/abs/2209.05433,
	// 8-bit Numerical Formats For Deep Neural Networks, https://arxiv.org/pdf/2206.02915.pdf.
	// Operators supported FP8 are Cast, CastLike, QuantizeLinear, DequantizeLinear.
	// The computation usually happens inside a block quantize / dequantize
	// fused by the runtime.
	TensorProto_FLOAT8E4M3FN   TensorProto_DataType = 17 // float 8, mostly used for coefficients, supports nan, not inf
	TensorProto_FLOAT8E4M3FNUZ TensorProto_DataType = 18 // float 8, mostly used for coefficients, supports nan, not inf, no negative zero
	TensorProto_FLOAT8E5M2     TensorProto_DataType = 19 // follows IEEE 754, supports nan, inf, mostly used for gradients
	TensorProto_FLOAT8E5M2FNUZ TensorProto_DataType = 20 // follows IEEE 754, supports nan, not inf, mostly used for gradients, no negative zero
	// 4-bit integer data types
	TensorProto_UINT4 TensorProto_DataType = 21 // Unsigned integer in range [0, 15]
	TensorProto_INT4  TensorProto_DataType = 22 // Signed integer in range [-8, 7], using two's-complement representation
	// 4-bit floating point data types
	TensorProto_FLOAT4E2M1 TensorProto_DataType = 23
	// E8M0 type used as the scale for microscaling (MX) formats:
	// https://www.opencompute.org/documents/ocp-microscaling-formats-mx-v1-0-spec-final-pdf
	TensorProto_FLOAT8E8M0 TensorProto_DataType = 24
)

// Enum value maps for TensorProto_DataType.
var (
	TensorProto_DataType_name = map[int32]string{
		0:  "UNDEFINED",
		1:  "FLOAT",
		2:  "UINT8",
		3:  "INT8",
		4:  "UINT16",
		5:  "INT16",
		6:  "INT32",
		7:  "INT64",
		8:  "STRING",
		9:  "BOOL",
		10: "FLOAT16",
		11: "DOUBLE",
		12: "UINT32",
		13: "UINT64",
		14: "COMPLEX64",
		15: "COMPLEX128",
		16: "BFLOAT16",
		17: "FLOAT8E4M3FN",
		18: "FLOAT8E4M3FNUZ",
		19: "FLOAT8E5M2",
		20: "FLOAT8E5M2FNUZ",
		21: "UINT4",
		22: "INT4",
		23: "FLOAT4E2M1",
		24: "FLOAT8E8M0",
	}
	TensorProto_DataType_value = map[string]int32{
		"UNDEFINED":      0,
		"FLOAT":          1,
		"UINT8":          2,
		"INT8":           3,
		"UINT16":         4,
		"INT16":          5,
		"INT32":          6,
		"INT64":          7,
		"STRING":         8,
		"BOOL":           9,
		"FLOAT16":        10,
		"DOUBLE":         11,
		"UINT32":         12,
		"UINT64":         13,
		"COMPLEX64":      14,
		"COMPLEX128":     15,
		"BFLOAT16":       16,
		"FLOAT8E4M3FN":   17,
		"FLOAT8E4M3FNUZ": 18,
		"FLOAT8E5M2":     19,
		"FLOAT8E5M2FNUZ": 20,
		"UINT4":          21,
		"INT4":           22,
		"FLOAT4E2M1":     23,
		"FLOAT8E8M0":     24,
	}
)

func (x TensorProto_DataType) Enum() *TensorProto_DataType {
	p := new(TensorProto_DataType)
	*p = x
	return p
}

func (x TensorProto_DataType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TensorProto_DataType) Descriptor() protoreflect.EnumDescriptor {
	return file_zonnx_internal_onnx_onnx_proto_enumTypes[3].Descriptor()
}

func (TensorProto_DataType) Type() protoreflect.EnumType {
	return &file_zonnx_internal_onnx_onnx_proto_enumTypes[3]
}

func (x TensorProto_DataType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *TensorProto_DataType) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = TensorProto_DataType(num)
	return nil
}

// Deprecated: Use TensorProto_DataType.Descriptor instead.
func (TensorProto_DataType) EnumDescriptor() ([]byte, []int) {
	return file_zonnx_internal_onnx_onnx_proto_rawDescGZIP(), []int{14, 0}
}

// Location of the data for this tensor. MUST be one of:
// - DEFAULT - data stored inside the protobuf message. Data is stored in raw_data (if set) otherwise in type-specified field.
// - EXTERNAL - data stored in an external location as described by external_data field.
type TensorProto_DataLocation int32

const (
	TensorProto_DEFAULT  TensorProto_DataLocation = 0
	TensorProto_EXTERNAL TensorProto_DataLocation = 1
)

// Enum value maps for TensorProto_DataLocation.
var (
	TensorProto_DataLocation_name = map[int32]string{
		0: "DEFAULT",
		1: "EXTERNAL",
	}
	TensorProto_DataLocation_value = map[string]int32{
		"DEFAULT":  0,
		"EXTERNAL": 1,
	}
)

func (x TensorProto_DataLocation) Enum() *TensorProto_DataLocation {
	p := new(TensorProto_DataLocation)
	*p = x
	return p
}

func (x TensorProto_DataLocation) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TensorProto_DataLocation) Descriptor() protoreflect.EnumDescriptor {
	return file_zonnx_internal_onnx_onnx_proto_enumTypes[4].Descriptor()
}

func (TensorProto_DataLocation) Type() protoreflect.EnumType {
	return &file_zonnx_internal_onnx_onnx_proto_enumTypes[4]
}

func (x TensorProto_DataLocation) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *TensorProto_DataLocation) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = TensorProto_DataLocation(num)
	return nil
}

// Deprecated: Use TensorProto_DataLocation.Descriptor instead.
func (TensorProto_DataLocation) EnumDescriptor() ([]byte, []int) {
	return file_zonnx_internal_onnx_onnx_proto_rawDescGZIP(), []int{14, 1}
}

// Attributes
//
// A named attribute containing either singular float, integer, string, graph,
// and tensor values, or repeated float, integer, string, graph, and tensor values.
// An AttributeProto MUST contain the name field, and *only one* of the
// following content fields, effectively enforcing a C/C++ union equivalent.
type AttributeProto struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The name field MUST be present for this version of the IR.
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"` // namespace Attribute
	// if ref_attr_name is not empty, ref_attr_name is the attribute name in parent function.
	// In this case, this AttributeProto does not contain data, and it's a reference of attribute
	// in parent scope.
	// NOTE: This should ONLY be used in function (sub-graph). It's invalid to be used in main graph.
	RefAttrName *string `protobuf:"bytes,21,opt,name=ref_attr_name,json=refAttrName" json:"ref_attr_name,omitempty"`
	// A human-readable documentation for this attribute. Markdown is allowed.
	DocString *string `protobuf:"bytes,13,opt,name=doc_string,json=docString" json:"doc_string,omitempty"`
	// The type field MUST be present for this version of the IR.
	// For 0.0.1 versions of the IR, this field was not defined, and
	// implementations needed to use has_field heuristics to determine
	// which value field was in use.  For IR_VERSION 0.0.2 or later, this
	// field MUST be set and match the f|i|s|t|... field in use.  This
	// change was made to accommodate proto3 implementations.
	Type *AttributeProto_AttributeType `protobuf:"varint,20,opt,name=type,enum=onnx.AttributeProto_AttributeType" json:"type,omitempty"` // discriminator that indicates which field below is in use
	// Exactly ONE of the following fields must be present for this version of the IR
	F            *float32           `protobuf:"fixed32,2,opt,name=f" json:"f,omitempty"`                                          // float
	I            *int64             `protobuf:"varint,3,opt,name=i" json:"i,omitempty"`                                           // int
	S            []byte             `protobuf:"bytes,4,opt,name=s" json:"s,omitempty"`                                            // UTF-8 string
	T            *TensorProto       `protobuf:"bytes,5,opt,name=t" json:"t,omitempty"`                                            // tensor value
	G            *GraphProto        `protobuf:"bytes,6,opt,name=g" json:"g,omitempty"`                                            // graph
	SparseTensor *SparseTensorProto `protobuf:"bytes,22,opt,name=sparse_tensor,json=sparseTensor" json:"sparse_tensor,omitempty"` // sparse tensor value
	// Do not use field below, it's deprecated.
	// optional ValueProto v = 12;         // value - subsumes everything but graph
	Tp            *TypeProto           `protobuf:"bytes,14,opt,name=tp" json:"tp,omitempty"`                                            // type proto
	Floats        []float32            `protobuf:"fixed32,7,rep,name=floats" json:"floats,omitempty"`                                   // list of floats
	Ints          []int64              `protobuf:"varint,8,rep,name=ints" json:"ints,omitempty"`                                        // list of ints
	Strings       [][]byte             `protobuf:"bytes,9,rep,name=strings" json:"strings,omitempty"`                                   // list of UTF-8 strings
	Tensors       []*TensorProto       `protobuf:"bytes,10,rep,name=tensors" json:"tensors,omitempty"`                                  // list of tensors
	Graphs        []*GraphProto        `protobuf:"bytes,11,rep,name=graphs" json:"graphs,omitempty"`                                    // list of graph
	SparseTensors []*SparseTensorProto `protobuf:"bytes,23,rep,name=sparse_tensors,json=sparseTensors" json:"sparse_tensors,omitempty"` // list of sparse tensors
	TypeProtos    []*TypeProto         `protobuf:"bytes,15,rep,name=type_protos,json=typeProtos" json:"type_protos,omitempty"`          // list of type protos
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AttributeProto) Reset() {
	*x = AttributeProto{}
	mi := &file_zonnx_internal_onnx_onnx_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AttributeProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AttributeProto) ProtoMessage() {}

func (x *AttributeProto) ProtoReflect() protoreflect.Message {
	mi := &file_zonnx_internal_onnx_onnx_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AttributeProto.ProtoReflect.Descriptor instead.
func (*AttributeProto) Descriptor() ([]byte, []int) {
	return file_zonnx_internal_onnx_onnx_proto_rawDescGZIP(), []int{0}
}

func (x *AttributeProto) GetName() string {
	if x != nil && x.Name != nil {
		return *x.Name
	}
	return ""
}

func (x *AttributeProto) GetRefAttrName() string {
	if x != nil && x.RefAttrName != nil {
		return *x.RefAttrName
	}
	return ""
}

func (x *AttributeProto) GetDocString() string {
	if x != nil && x.DocString != nil {
		return *x.DocString
	}
	return ""
}

func (x *AttributeProto) GetType() AttributeProto_AttributeType {
	if x != nil && x.Type != nil {
		return *x.Type
	}
	return AttributeProto_UNDEFINED
}

func (x *AttributeProto) GetF() float32 {
	if x != nil && x.F != nil {
		return *x.F
	}
	return 0
}

func (x *AttributeProto) GetI() int64 {
	if x != nil && x.I != nil {
		return *x.I
	}
	return 0
}

func (x *AttributeProto) GetS() []byte {
	if x != nil {
		return x.S
	}
	return nil
}

func (x *AttributeProto) GetT() *TensorProto {
	if x != nil {
		return x.T
	}
	return nil
}

func (x *AttributeProto) GetG() *GraphProto {
	if x != nil {
		return x.G
	}
	return nil
}

func (x *AttributeProto) GetSparseTensor() *SparseTensorProto {
	if x != nil {
		return x.SparseTensor
	}
	return nil
}

func (x *AttributeProto) GetTp() *TypeProto {
	if x != nil {
		return x.Tp
	}
	return nil
}

func (x *AttributeProto) GetFloats() []float32 {
	if x != nil {
		return x.Floats
	}
	return nil
}

func (x *AttributeProto) GetInts() []int64 {
	if x != nil {
		return x.Ints
	}
	return nil
}

func (x *AttributeProto) GetStrings() [][]byte {
	if x != nil {
		return x.Strings
	}
	return nil
}

func (x *AttributeProto) GetTensors() []*TensorProto {
	if x != nil {
		return x.Tensors
	}
	return nil
}

func (x *AttributeProto) GetGraphs() []*GraphProto {
	if x != nil {
		return x.Graphs
	}
	return nil
}

func (x *AttributeProto) GetSparseTensors() []*SparseTensorProto {
	if x != nil {
		return x.SparseTensors
	}
	return nil
}

func (x *AttributeProto) GetTypeProtos() []*TypeProto {
	if x != nil {
		return x.TypeProtos
	}
	return nil
}

// Defines information on value, including the name, the type, and
// the shape of the value.
type ValueInfoProto struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// This field MUST be present in this version of the IR.
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"` // namespace Value
	// This field MUST be present in this version of the IR for
	// inputs and outputs of the top-level graph.
	Type *TypeProto `protobuf:"bytes,2,opt,name=type" json:"type,omitempty"`
	// A human-readable documentation for this value. Markdown is allowed.
	DocString *string `protobuf:"bytes,3,opt,name=doc_string,json=docString" json:"doc_string,omitempty"`
	// Named metadata values; keys should be distinct.
	MetadataProps []*StringStringEntryProto `protobuf:"bytes,4,rep,name=metadata_props,json=metadataProps" json:"metadata_props,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ValueInfoProto) Reset() {
	*x = ValueInfoProto{}
	mi := &file_zonnx_internal_onnx_onnx_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ValueInfoProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ValueInfoProto) ProtoMessage() {}

func (x *ValueInfoProto) ProtoReflect() protoreflect.Message {
	mi := &file_zonnx_internal_onnx_onnx_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ValueInfoProto.ProtoReflect.Descriptor instead.
func (*ValueInfoProto) Descriptor() ([]byte, []int) {
	return file_zonnx_internal_onnx_onnx_proto_rawDescGZIP(), []int{1}
}

func (x *ValueInfoProto) GetName() string {
	if x != nil && x.Name != nil {
		return *x.Name
	}
	return ""
}

func (x *ValueInfoProto) GetType() *TypeProto {
	if x != nil {
		return x.Type
	}
	return nil
}

func (x *ValueInfoProto) GetDocString() string {
	if x != nil && x.DocString != nil {
		return *x.DocString
	}
	return ""
}

func (x *ValueInfoProto) GetMetadataProps() []*StringStringEntryProto {
	if x != nil {
		return x.MetadataProps
	}
	return nil
}

// Nodes
//
// Computation graphs are made up of a DAG of nodes, which represent what is
// commonly called a "layer" or "pipeline stage" in machine learning frameworks.
//
// For example, it can be a node of type "Conv" that takes in an image, a filter
// tensor and a bias tensor, and produces the convolved output.
type NodeProto struct {
	state  protoimpl.MessageState `protogen:"open.v1"`
	Input  []string               `protobuf:"bytes,1,rep,name=input" json:"input,omitempty"`   // namespace Value
	Output []string               `protobuf:"bytes,2,rep,name=output" json:"output,omitempty"` // namespace Value
	// An optional identifier for this node in a graph.
	// This field MAY be absent in this version of the IR.
	Name *string `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"` // namespace Node
	// The symbolic identifier of the Operator to execute.
	OpType *string `protobuf:"bytes,4,opt,name=op_type,json=opType" json:"op_type,omitempty"` // namespace Operator
	// The domain of the OperatorSet that specifies the operator named by op_type.
	Domain *string `protobuf:"bytes,7,opt,name=domain" json:"domain,omitempty"` // namespace Domain
	// Overload identifier, used only to map this to a model-local function.
	Overload *string `protobuf:"bytes,8,opt,name=overload" json:"overload,omitempty"`
	// Additional named attributes.
	Attribute []*AttributeProto `protobuf:"bytes,5,rep,name=attribute" json:"attribute,omitempty"`
	// A human-readable documentation for this node. Markdown is allowed.
	DocString *string `protobuf:"bytes,6,opt,name=doc_string,json=docString" json:"doc_string,omitempty"`
	// Named metadata values; keys should be distinct.
	MetadataProps []*StringStringEntryProto `protobuf:"bytes,9,rep,name=metadata_props,json=metadataProps" json:"metadata_props,omitempty"`
	// Configuration of multi-device annotations.
	DeviceConfigurations []*NodeDeviceConfigurationProto `protobuf:"bytes,10,rep,name=device_configurations,json=deviceConfigurations" json:"device_configurations,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *NodeProto) Reset() {
	*x = NodeProto{}
	mi := &file_zonnx_internal_onnx_onnx_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeProto) ProtoMessage() {}

func (x *NodeProto) ProtoReflect() protoreflect.Message {
	mi := &file_zonnx_internal_onnx_onnx_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeProto.ProtoReflect.Descriptor instead.
func (*NodeProto) Descriptor() ([]byte, []int) {
	return file_zonnx_internal_onnx_onnx_proto_rawDescGZIP(), []int{2}
}

func (x *NodeProto) GetInput() []string {
	if x != nil {
		return x.Input
	}
	return nil
}

func (x *NodeProto) GetOutput() []string {
	if x != nil {
		return x.Output
	}
	return nil
}

func (x *NodeProto) GetName() string {
	if x != nil && x.Name != nil {
		return *x.Name
	}
	return ""
}

func (x *NodeProto) GetOpType() string {
	if x != nil && x.OpType != nil {
		return *x.OpType
	}
	return ""
}

func (x *NodeProto) GetDomain() string {
	if x != nil && x.Domain != nil {
		return *x.Domain
	}
	return ""
}

func (x *NodeProto) GetOverload() string {
	if x != nil && x.Overload != nil {
		return *x.Overload
	}
	return ""
}

func (x *NodeProto) GetAttribute() []*AttributeProto {
	if x != nil {
		return x.Attribute
	}
	return nil
}

func (x *NodeProto) GetDocString() string {
	if x != nil && x.DocString != nil {
		return *x.DocString
	}
	return ""
}

func (x *NodeProto) GetMetadataProps() []*StringStringEntryProto {
	if x != nil {
		return x.MetadataProps
	}
	return nil
}

func (x *NodeProto) GetDeviceConfigurations() []*NodeDeviceConfigurationProto {
	if x != nil {
		return x.DeviceConfigurations
	}
	return nil
}

// IntIntListEntryProto follows the pattern for cross-proto-version maps.
// See https://developers.google.com/protocol-buffers/docs/proto3#maps
type IntIntListEntryProto struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Key           *int64                 `protobuf:"varint,1,opt,name=key" json:"key,omitempty"`
	Value         []int64                `protobuf:"varint,2,rep,name=value" json:"value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IntIntListEntryProto) Reset() {
	*x = IntIntListEntryProto{}
	mi := &file_zonnx_internal_onnx_onnx_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IntIntListEntryProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IntIntListEntryProto) ProtoMessage() {}

func (x *IntIntListEntryProto) ProtoReflect() protoreflect.Message {
	mi := &file_zonnx_internal_onnx_onnx_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IntIntListEntryProto.ProtoReflect.Descriptor instead.
func (*IntIntListEntryProto) Descriptor() ([]byte, []int) {
	return file_zonnx_internal_onnx_onnx_proto_rawDescGZIP(), []int{3}
}

func (x *IntIntListEntryProto) GetKey() int64 {
	if x != nil && x.Key != nil {
		return *x.Key
	}
	return 0
}

func (x *IntIntListEntryProto) GetValue() []int64 {
	if x != nil {
		return x.Value
	}
	return nil
}

// Multi-device configuration proto for NodeProto.
type NodeDeviceConfigurationProto struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// This field MUST be present for this version of the IR.
	// ID of the configuration. MUST match the name of a DeviceConfigurationProto.
	ConfigurationId *string `protobuf:"bytes,1,opt,name=configuration_id,json=configurationId" json:"configuration_id,omitempty"`
	// Sharding spec for the node.
	ShardingSpec []*ShardingSpecProto `protobuf:"bytes,2,rep,name=sharding_spec,json=shardingSpec" json:"sharding_spec,omitempty"`
	// Pipeline stage of this node.
	PipelineStage *int32 `protobuf:"varint,3,opt,name=pipeline_stage,json=pipelineStage" json:"pipeline_stage,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NodeDeviceConfigurationProto) Reset() {
	*x = NodeDeviceConfigurationProto{}
	mi := &file_zonnx_internal_onnx_onnx_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeDeviceConfigurationProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeDeviceConfigurationProto) ProtoMessage() {}

func (x *NodeDeviceConfigurationProto) ProtoReflect() protoreflect.Message {
	mi := &file_zonnx_internal_onnx_onnx_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeDeviceConfigurationProto.ProtoReflect.Descriptor instead.
func (*NodeDeviceConfigurationProto) Descriptor() ([]byte, []int) {
	return file_zonnx_internal_onnx_onnx_proto_rawDescGZIP(), []int{4}
}

func (x *NodeDeviceConfigurationProto) GetConfigurationId() string {
	if x != nil && x.ConfigurationId != nil {
		return *x.ConfigurationId
	}
	return ""
}

func (x *NodeDeviceConfigurationProto) GetShardingSpec() []*ShardingSpecProto {
	if x != nil {
		return x.ShardingSpec
	}
	return nil
}

func (x *NodeDeviceConfigurationProto) GetPipelineStage() int32 {
	if x != nil && x.PipelineStage != nil {
		return *x.PipelineStage
	}
	return 0
}

// ShardingSpecProto: This describes the sharding spec for a specific
// input or output tensor of a node.
type ShardingSpecProto struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// This field MUST be present for this version of the IR.
	// Identifies the input or output of the node that is being sharded.
	// Required to match a name specified in the node's input or output list of ValueInfoProtos.
	// It is called `logical tensor` in subsequent descriptions.
	TensorName *string `protobuf:"bytes,1,opt,name=tensor_name,json=tensorName" json:"tensor_name,omitempty"`
	// The following is the list of devices across which the logical
	// tensor is sharded or replicated.
	Device []int64 `protobuf:"varint,2,rep,name=device" json:"device,omitempty"`
	// Each element v in above field devices may represent either a
	// device or a set of devices (when we want the same shard/tensor
	// to be replicated across a subset of devices), as indicated by
	// the following optional map. If the map contains an entry for v,
	// then v represents a device group, and the map indicates the set
	// of devices in that group.
	IndexToDeviceGroupMap []*IntIntListEntryProto `protobuf:"bytes,3,rep,name=index_to_device_group_map,json=indexToDeviceGroupMap" json:"index_to_device_group_map,omitempty"`
	// The following is the sharded-shape of the tensor, consisting of
	// the sharding-spec for each axis of the tensor.
	ShardedDim    []*ShardedDimProto `protobuf:"bytes,4,rep,name=sharded_dim,json=shardedDim" json:"sharded_dim,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ShardingSpecProto) Reset() {
	*x = ShardingSpecProto{}
	mi := &file_zonnx_internal_onnx_onnx_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ShardingSpecProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ShardingSpecProto) ProtoMessage() {}

func (x *ShardingSpecProto) ProtoReflect() protoreflect.Message {
	mi := &file_zonnx_internal_onnx_onnx_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ShardingSpecProto.ProtoReflect.Descriptor instead.
func (*ShardingSpecProto) Descriptor() ([]byte, []int) {
	return file_zonnx_internal_onnx_onnx_proto_rawDescGZIP(), []int{5}
}

func (x *ShardingSpecProto) GetTensorName() string {
	if x != nil && x.TensorName != nil {
		return *x.TensorName
	}
	return ""
}

func (x *ShardingSpecProto) GetDevice() []int64 {
	if x != nil {
		return x.Device
	}
	return nil
}

func (x *ShardingSpecProto) GetIndexToDeviceGroupMap() []*IntIntListEntryProto {
	if x != nil {
		return x.IndexToDeviceGroupMap
	}
	return nil
}

func (x *ShardingSpecProto) GetShardedDim() []*ShardedDimProto {
	if x != nil {
		return x.ShardedDim
	}
	return nil
}

// ShardedDimProto: This describes the sharding spec for a single
// axis of a sharded tensor.
type ShardedDimProto struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// This field MUST be present for this version of the IR.
	// The axis this sharding corresponds to. Must be in the range of
	// [-r, r - 1], where r is the rank of the tensor. Negative axis values means
	// counting from the back.
	Axis *int64 `protobuf:"varint,1,opt,name=axis" json:"axis,omitempty"`
	// Describes how the tensor on the provided axis is sharded.
	// The common-case is described by a single instance of SimpleShardedDimProto.
	// Multiple instances can be used to handle cases where a sharded
	// tensor is reshaped, fusing multiple axes into one.
	SimpleSharding []*SimpleShardedDimProto `protobuf:"bytes,2,rep,name=simple_sharding,json=simpleSharding" json:"simple_sharding,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *ShardedDimProto) Reset() {
	*x = ShardedDimProto{}
	mi := &file_zonnx_internal_onnx_onnx_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ShardedDimProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ShardedDimProto) ProtoMessage() {}

func (x *ShardedDimProto) ProtoReflect() protoreflect.Message {
	mi := &file_zonnx_internal_onnx_onnx_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ShardedDimProto.ProtoReflect.Descriptor instead.
func (*ShardedDimProto) Descriptor() ([]byte, []int) {
	return file_zonnx_internal_onnx_onnx_proto_rawDescGZIP(), []int{6}
}

func (x *ShardedDimProto) GetAxis() int64 {
	if x != nil && x.Axis != nil {
		return *x.Axis
	}
	return 0
}

func (x *ShardedDimProto) GetSimpleSharding() []*SimpleShardedDimProto {
	if x != nil {
		return x.SimpleSharding
	}
	return nil
}

// SimpleShardedDimProto: Indicates that N blocks are divided into M shards.
// N is allowed to be symbolic where M is required to be a constant.
type SimpleShardedDimProto struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Dimension value to be sharded.
	//
	// Types that are valid to be assigned to Dim:
	//
	//	*SimpleShardedDimProto_DimValue
	//	*SimpleShardedDimProto_DimParam
	Dim isSimpleShardedDimProto_Dim `protobuf_oneof:"dim"`
	// This field MUST be present for this version of the IR.
	// Number of shards to split dim into.
	NumShards     *int64 `protobuf:"varint,3,opt,name=num_shards,json=numShards" json:"num_shards,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SimpleShardedDimProto) Reset() {
	*x = SimpleShardedDimProto{}
	mi := &file_zonnx_internal_onnx_onnx_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SimpleShardedDimProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SimpleShardedDimProto) ProtoMessage() {}

func (x *SimpleShardedDimProto) ProtoReflect() protoreflect.Message {
	mi := &file_zonnx_internal_onnx_onnx_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SimpleShardedDimProto.ProtoReflect.Descriptor instead.
func (*SimpleShardedDimProto) Descriptor() ([]byte, []int) {
	return file_zonnx_internal_onnx_onnx_proto_rawDescGZIP(), []int{7}
}

func (x *SimpleShardedDimProto) GetDim() isSimpleShardedDimProto_Dim {
	if x != nil {
		return x.Dim
	}
	return nil
}

func (x *SimpleShardedDimProto) GetDimValue() int64 {
	if x != nil {
		if x, ok := x.Dim.(*SimpleShardedDimProto_DimValue); ok {
			return x.DimValue
		}
	}
	return 0
}

func (x *SimpleShardedDimProto) GetDimParam() string {
	if x != nil {
		if x, ok := x.Dim.(*SimpleShardedDimProto_DimParam); ok {
			return x.DimParam
		}
	}
	return ""
}

func (x *SimpleShardedDimProto) GetNumShards() int64 {
	if x != nil && x.NumShards != nil {
		return *x.NumShards
	}
	return 0
}

type isSimpleShardedDimProto_Dim interface {
	isSimpleShardedDimProto_Dim()
}

type SimpleShardedDimProto_DimValue struct {
	DimValue int64 `protobuf:"varint,1,opt,name=dim_value,json=dimValue,oneof"`
}

type SimpleShardedDimProto_DimParam struct {
	DimParam string `protobuf:"bytes,2,opt,name=dim_param,json=dimParam,oneof"`
}

func (*SimpleShardedDimProto_DimValue) isSimpleShardedDimProto_Dim() {}

func (*SimpleShardedDimProto_DimParam) isSimpleShardedDimProto_Dim() {}

// Training information
// TrainingInfoProto stores information for training a model.
// In particular, this defines two functionalities: an initialization-step
// and a training-algorithm-step. Initialization resets the model
// back to its original state as if no training has been performed.
// Training algorithm improves the model based on input data.
//
// The semantics of the initialization-step is that the initializers
// in ModelProto.graph and in TrainingInfoProto.algorithm are first
// initialized as specified by the initializers in the graph, and then
// updated by the "initialization_binding" in every instance in
// ModelProto.training_info.
//
// The field "algorithm" defines a computation graph which represents a
// training algorithm's step. After the execution of a
// TrainingInfoProto.algorithm, the initializers specified by "update_binding"
// may be immediately updated. If the targeted training algorithm contains
// consecutive update steps (such as block coordinate descent methods),
// the user needs to create a TrainingInfoProto for each step.
type TrainingInfoProto struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// This field describes a graph to compute the initial tensors
	// upon starting the training process. Initialization graph has no input
	// and can have multiple outputs. Usually, trainable tensors in neural
	// networks are randomly initialized. To achieve that, for each tensor,
	// the user can put a random number operator such as RandomNormal or
	// RandomUniform in TrainingInfoProto.initialization.node and assign its
	// random output to the specific tensor using "initialization_binding".
	// This graph can also set the initializers in "algorithm" in the same
	// TrainingInfoProto; a use case is resetting the number of training
	// iteration to zero.
	//
	// By default, this field is an empty graph and its evaluation does not
	// produce any output. Thus, no initializer would be changed by default.
	Initialization *GraphProto `protobuf:"bytes,1,opt,name=initialization" json:"initialization,omitempty"`
	// This field represents a training algorithm step. Given required inputs,
	// it computes outputs to update initializers in its own or inference graph's
	// initializer lists. In general, this field contains loss node, gradient node,
	// optimizer node, increment of iteration count.
	//
	// An execution of the training algorithm step is performed by executing the
	// graph obtained by combining the inference graph (namely "ModelProto.graph")
	// and the "algorithm" graph. That is, the actual
	// input/initializer/output/node/value_info/sparse_initializer list of
	// the training graph is the concatenation of
	// "ModelProto.graph.input/initializer/output/node/value_info/sparse_initializer"
	// and "algorithm.input/initializer/output/node/value_info/sparse_initializer"
	// in that order. This combined graph must satisfy the normal ONNX conditions.
	// Now, let's provide a visualization of graph combination for clarity.
	// Let the inference graph (i.e., "ModelProto.graph") be
	//
	//	tensor_a, tensor_b -> MatMul -> tensor_c -> Sigmoid -> tensor_d
	//
	// and the "algorithm" graph be
	//
	//	tensor_d -> Add -> tensor_e
	//
	// The combination process results
	//
	//	tensor_a, tensor_b -> MatMul -> tensor_c -> Sigmoid -> tensor_d -> Add -> tensor_e
	//
	// Notice that an input of a node in the "algorithm" graph may reference the
	// output of a node in the inference graph (but not the other way round). Also, inference
	// node cannot reference inputs of "algorithm". With these restrictions, inference graph
	// can always be run independently without training information.
	//
	// By default, this field is an empty graph and its evaluation does not
	// produce any output. Evaluating the default training step never
	// update any initializers.
	Algorithm *GraphProto `protobuf:"bytes,2,opt,name=algorithm" json:"algorithm,omitempty"`
	// This field specifies the bindings from the outputs of "initialization" to
	// some initializers in "ModelProto.graph.initializer" and
	// the "algorithm.initializer" in the same TrainingInfoProto.
	// See "update_binding" below for details.
	//
	// By default, this field is empty and no initializer would be changed
	// by the execution of "initialization".
	InitializationBinding []*StringStringEntryProto `protobuf:"bytes,3,rep,name=initialization_binding,json=initializationBinding" json:"initialization_binding,omitempty"`
	// Gradient-based training is usually an iterative procedure. In one gradient
	// descent iteration, we apply
	//
	// x = x - r * g
	//
	// where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
	// gradient of "x" with respect to a chosen loss. To avoid adding assignments
	// into the training graph, we split the update equation into
	//
	// y = x - r * g
	// x = y
	//
	// The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
	// tell that "y" should be assigned to "x", the field "update_binding" may
	// contain a key-value pair of strings, "x" (key of StringStringEntryProto)
	// and "y" (value of StringStringEntryProto).
	// For a neural network with multiple trainable (mutable) tensors, there can
	// be multiple key-value pairs in "update_binding".
	//
	// The initializers appears as keys in "update_binding" are considered
	// mutable variables. This implies some behaviors
	// as described below.
	//
	//  1. We have only unique keys in all "update_binding"s so that two
	//     variables may not have the same name. This ensures that one
	//     variable is assigned up to once.
	//  2. The keys must appear in names of "ModelProto.graph.initializer" or
	//     "TrainingInfoProto.algorithm.initializer".
	//  3. The values must be output names of "algorithm" or "ModelProto.graph.output".
	//  4. Mutable variables are initialized to the value specified by the
	//     corresponding initializer, and then potentially updated by
	//     "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
	//
	// This field usually contains names of trainable tensors
	// (in ModelProto.graph), optimizer states such as momentums in advanced
	// stochastic gradient methods (in TrainingInfoProto.graph),
	// and number of training iterations (in TrainingInfoProto.graph).
	//
	// By default, this field is empty and no initializer would be changed
	// by the execution of "algorithm".
	UpdateBinding []*StringStringEntryProto `protobuf:"bytes,4,rep,name=update_binding,json=updateBinding" json:"update_binding,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TrainingInfoProto) Reset() {
	*x = TrainingInfoProto{}
	mi := &file_zonnx_internal_onnx_onnx_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TrainingInfoProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TrainingInfoProto) ProtoMessage() {}

func (x *TrainingInfoProto) ProtoReflect() protoreflect.Message {
	mi := &file_zonnx_internal_onnx_onnx_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TrainingInfoProto.ProtoReflect.Descriptor instead.
func (*TrainingInfoProto) Descriptor() ([]byte, []int) {
	return file_zonnx_internal_onnx_onnx_proto_rawDescGZIP(), []int{8}
}

func (x *TrainingInfoProto) GetInitialization() *GraphProto {
	if x != nil {
		return x.Initialization
	}
	return nil
}

func (x *TrainingInfoProto) GetAlgorithm() *GraphProto {
	if x != nil {
		return x.Algorithm
	}
	return nil
}

func (x *TrainingInfoProto) GetInitializationBinding() []*StringStringEntryProto {
	if x != nil {
		return x.InitializationBinding
	}
	return nil
}

func (x *TrainingInfoProto) GetUpdateBinding() []*StringStringEntryProto {
	if x != nil {
		return x.UpdateBinding
	}
	return nil
}

// Models
//
// ModelProto is a top-level file/container format for bundling a ML model and
// associating its computation graph with metadata.
//
// The semantics of the model are described by the associated GraphProto's.
type ModelProto struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The version of the IR this model targets. See Version enum above.
	// This field MUST be present.
	IrVersion *int64 `protobuf:"varint,1,opt,name=ir_version,json=irVersion" json:"ir_version,omitempty"`
	// The OperatorSets this model relies on.
	// All ModelProtos MUST have at least one entry that
	// specifies which version of the ONNX OperatorSet is
	// being imported.
	//
	// All nodes in the ModelProto's graph will bind against the operator
	// with the same-domain/same-op_type operator with the HIGHEST version
	// in the referenced operator sets.
	OpsetImport []*OperatorSetIdProto `protobuf:"bytes,8,rep,name=opset_import,json=opsetImport" json:"opset_import,omitempty"`
	// The name of the framework or tool used to generate this model.
	// This field SHOULD be present to indicate which implementation/tool/framework
	// emitted the model.
	ProducerName *string `protobuf:"bytes,2,opt,name=producer_name,json=producerName" json:"producer_name,omitempty"`
	// The version of the framework or tool used to generate this model.
	// This field SHOULD be present to indicate which implementation/tool/framework
	// emitted the model.
	ProducerVersion *string `protobuf:"bytes,3,opt,name=producer_version,json=producerVersion" json:"producer_version,omitempty"`
	// Domain name of the model.
	// We use reverse domain names as name space indicators. For example:
	// `com.facebook.fair` or `com.microsoft.cognitiveservices`
	//
	// Together with `model_version` and GraphProto.name, this forms the unique identity of
	// the graph.
	Domain *string `protobuf:"bytes,4,opt,name=domain" json:"domain,omitempty"`
	// The version of the graph encoded. See Version enum below.
	ModelVersion *int64 `protobuf:"varint,5,opt,name=model_version,json=modelVersion" json:"model_version,omitempty"`
	// A human-readable documentation for this model. Markdown is allowed.
	DocString *string `protobuf:"bytes,6,opt,name=doc_string,json=docString" json:"doc_string,omitempty"`
	// The parameterized graph that is evaluated to execute the model.
	Graph *GraphProto `protobuf:"bytes,7,opt,name=graph" json:"graph,omitempty"`
	// Named metadata values; keys should be distinct.
	MetadataProps []*StringStringEntryProto `protobuf:"bytes,14,rep,name=metadata_props,json=metadataProps" json:"metadata_props,omitempty"`
	// Training-specific information. Sequentially executing all stored
	// `TrainingInfoProto.algorithm`s and assigning their outputs following
	// the corresponding `TrainingInfoProto.update_binding`s is one training
	// iteration. Similarly, to initialize the model
	// (as if training hasn't happened), the user should sequentially execute
	// all stored `TrainingInfoProto.initialization`s and assigns their outputs
	// using `TrainingInfoProto.initialization_binding`s.
	//
	// If this field is empty, the training behavior of the model is undefined.
	TrainingInfo []*TrainingInfoProto `protobuf:"bytes,20,rep,name=training_info,json=trainingInfo" json:"training_info,omitempty"`
	// A list of function protos local to the model.
	//
	// The (domain, name, overload) tuple must be unique across the function protos in this list.
	// In case of any conflicts the behavior (whether the model local functions are given higher priority,
	// or standard operator sets are given higher priority or this is treated as error) is defined by
	// the runtimes.
	//
	// The operator sets imported by FunctionProto should be compatible with the ones
	// imported by ModelProto and other model local FunctionProtos.
	// Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto
	// or by 2 FunctionProtos then versions for the operator set may be different but,
	// the operator schema returned for op_type, domain, version combination
	// for both the versions should be same for every node in the function body.
	//
	// One FunctionProto can reference other FunctionProto in the model, however, recursive reference
	// is not allowed.
	Functions []*FunctionProto `protobuf:"bytes,25,rep,name=functions" json:"functions,omitempty"`
	// Describes different target configurations for a multi-device use case.
	// A model MAY describe multiple multi-device configurations for execution.
	Configuration []*DeviceConfigurationProto `protobuf:"bytes,26,rep,name=configuration" json:"configuration,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ModelProto) Reset() {
	*x = ModelProto{}
	mi := &file_zonnx_internal_onnx_onnx_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ModelProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ModelProto) ProtoMessage() {}

func (x *ModelProto) ProtoReflect() protoreflect.Message {
	mi := &file_zonnx_internal_onnx_onnx_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ModelProto.ProtoReflect.Descriptor instead.
func (*ModelProto) Descriptor() ([]byte, []int) {
	return file_zonnx_internal_onnx_onnx_proto_rawDescGZIP(), []int{9}
}

func (x *ModelProto) GetIrVersion() int64 {
	if x != nil && x.IrVersion != nil {
		return *x.IrVersion
	}
	return 0
}

func (x *ModelProto) GetOpsetImport() []*OperatorSetIdProto {
	if x != nil {
		return x.OpsetImport
	}
	return nil
}

func (x *ModelProto) GetProducerName() string {
	if x != nil && x.ProducerName != nil {
		return *x.ProducerName
	}
	return ""
}

func (x *ModelProto) GetProducerVersion() string {
	if x != nil && x.ProducerVersion != nil {
		return *x.ProducerVersion
	}
	return ""
}

func (x *ModelProto) GetDomain() string {
	if x != nil && x.Domain != nil {
		return *x.Domain
	}
	return ""
}

func (x *ModelProto) GetModelVersion() int64 {
	if x != nil && x.ModelVersion != nil {
		return *x.ModelVersion
	}
	return 0
}

func (x *ModelProto) GetDocString() string {
	if x != nil && x.DocString != nil {
		return *x.DocString
	}
	return ""
}

func (x *ModelProto) GetGraph() *GraphProto {
	if x != nil {
		return x.Graph
	}
	return nil
}

func (x *ModelProto) GetMetadataProps() []*StringStringEntryProto {
	if x != nil {
		return x.MetadataProps
	}
	return nil
}

func (x *ModelProto) GetTrainingInfo() []*TrainingInfoProto {
	if x != nil {
		return x.TrainingInfo
	}
	return nil
}

func (x *ModelProto) GetFunctions() []*FunctionProto {
	if x != nil {
		return x.Functions
	}
	return nil
}

func (x *ModelProto) GetConfiguration() []*DeviceConfigurationProto {
	if x != nil {
		return x.Configuration
	}
	return nil
}

// DeviceConfigurationProto describes a multi-device configuration for a model.
type DeviceConfigurationProto struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// This field MUST be present for this version of the IR.
	// Name of the configuration.
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// This field MUST be present for this version of the IR.
	// Number of devices inside this configuration.
	NumDevices *int32 `protobuf:"varint,2,opt,name=num_devices,json=numDevices" json:"num_devices,omitempty"`
	// Optional names of the devices. MUST be length of num_devices if provided.
	Device        []string `protobuf:"bytes,3,rep,name=device" json:"device,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeviceConfigurationProto) Reset() {
	*x = DeviceConfigurationProto{}
	mi := &file_zonnx_internal_onnx_onnx_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeviceConfigurationProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeviceConfigurationProto) ProtoMessage() {}

func (x *DeviceConfigurationProto) ProtoReflect() protoreflect.Message {
	mi := &file_zonnx_internal_onnx_onnx_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeviceConfigurationProto.ProtoReflect.Descriptor instead.
func (*DeviceConfigurationProto) Descriptor() ([]byte, []int) {
	return file_zonnx_internal_onnx_onnx_proto_rawDescGZIP(), []int{10}
}

func (x *DeviceConfigurationProto) GetName() string {
	if x != nil && x.Name != nil {
		return *x.Name
	}
	return ""
}

func (x *DeviceConfigurationProto) GetNumDevices() int32 {
	if x != nil && x.NumDevices != nil {
		return *x.NumDevices
	}
	return 0
}

func (x *DeviceConfigurationProto) GetDevice() []string {
	if x != nil {
		return x.Device
	}
	return nil
}

// StringStringEntryProto follows the pattern for cross-proto-version maps.
// See https://developers.google.com/protocol-buffers/docs/proto3#maps
type StringStringEntryProto struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Key           *string                `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Value         *string                `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StringStringEntryProto) Reset() {
	*x = StringStringEntryProto{}
	mi := &file_zonnx_internal_onnx_onnx_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StringStringEntryProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StringStringEntryProto) ProtoMessage() {}

func (x *StringStringEntryProto) ProtoReflect() protoreflect.Message {
	mi := &file_zonnx_internal_onnx_onnx_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StringStringEntryProto.ProtoReflect.Descriptor instead.
func (*StringStringEntryProto) Descriptor() ([]byte, []int) {
	return file_zonnx_internal_onnx_onnx_proto_rawDescGZIP(), []int{11}
}

func (x *StringStringEntryProto) GetKey() string {
	if x != nil && x.Key != nil {
		return *x.Key
	}
	return ""
}

func (x *StringStringEntryProto) GetValue() string {
	if x != nil && x.Value != nil {
		return *x.Value
	}
	return ""
}

type TensorAnnotation struct {
	state      protoimpl.MessageState `protogen:"open.v1"`
	TensorName *string                `protobuf:"bytes,1,opt,name=tensor_name,json=tensorName" json:"tensor_name,omitempty"`
	// <key, value> pairs to annotate tensor specified by <tensor_name> above.
	// The keys used in the mapping below must be pre-defined in ONNX spec.
	// For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
	// quantization parameter keys.
	QuantParameterTensorNames []*StringStringEntryProto `protobuf:"bytes,2,rep,name=quant_parameter_tensor_names,json=quantParameterTensorNames" json:"quant_parameter_tensor_names,omitempty"`
	unknownFields             protoimpl.UnknownFields
	sizeCache                 protoimpl.SizeCache
}

func (x *TensorAnnotation) Reset() {
	*x = TensorAnnotation{}
	mi := &file_zonnx_internal_onnx_onnx_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TensorAnnotation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TensorAnnotation) ProtoMessage() {}

func (x *TensorAnnotation) ProtoReflect() protoreflect.Message {
	mi := &file_zonnx_internal_onnx_onnx_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TensorAnnotation.ProtoReflect.Descriptor instead.
func (*TensorAnnotation) Descriptor() ([]byte, []int) {
	return file_zonnx_internal_onnx_onnx_proto_rawDescGZIP(), []int{12}
}

func (x *TensorAnnotation) GetTensorName() string {
	if x != nil && x.TensorName != nil {
		return *x.TensorName
	}
	return ""
}

func (x *TensorAnnotation) GetQuantParameterTensorNames() []*StringStringEntryProto {
	if x != nil {
		return x.QuantParameterTensorNames
	}
	return nil
}

// Graphs
//
// A graph defines the computational logic of a model and is comprised of a parameterized
// list of nodes that form a directed acyclic graph based on their inputs and outputs.
// This is the equivalent of the "network" or "graph" in many deep learning
// frameworks.
type GraphProto struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The nodes in the graph, sorted topologically.
	Node []*NodeProto `protobuf:"bytes,1,rep,name=node" json:"node,omitempty"`
	// The name of the graph.
	Name *string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"` // namespace Graph
	// A list of named tensor values, used to specify constant inputs of the graph.
	// Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
	// The name MUST be unique across both initializer and sparse_initializer,
	// but the name MAY also appear in the input list.
	Initializer []*TensorProto `protobuf:"bytes,5,rep,name=initializer" json:"initializer,omitempty"`
	// Initializers (see above) stored in sparse format.
	SparseInitializer []*SparseTensorProto `protobuf:"bytes,15,rep,name=sparse_initializer,json=sparseInitializer" json:"sparse_initializer,omitempty"`
	// A human-readable documentation for this graph. Markdown is allowed.
	DocString *string `protobuf:"bytes,10,opt,name=doc_string,json=docString" json:"doc_string,omitempty"`
	// The inputs and outputs of the graph.
	Input  []*ValueInfoProto `protobuf:"bytes,11,rep,name=input" json:"input,omitempty"`
	Output []*ValueInfoProto `protobuf:"bytes,12,rep,name=output" json:"output,omitempty"`
	// Information for the values in the graph. The ValueInfoProto.name's
	// must be distinct. It is optional for a value to appear in value_info list.
	ValueInfo []*ValueInfoProto `protobuf:"bytes,13,rep,name=value_info,json=valueInfo" json:"value_info,omitempty"`
	// This field carries information to indicate the mapping among a tensor and its
	// quantization parameter tensors. For example:
	// For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
	// which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
	QuantizationAnnotation []*TensorAnnotation `protobuf:"bytes,14,rep,name=quantization_annotation,json=quantizationAnnotation" json:"quantization_annotation,omitempty"`
	// Named metadata values; keys should be distinct.
	MetadataProps []*StringStringEntryProto `protobuf:"bytes,16,rep,name=metadata_props,json=metadataProps" json:"metadata_props,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GraphProto) Reset() {
	*x = GraphProto{}
	mi := &file_zonnx_internal_onnx_onnx_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GraphProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GraphProto) ProtoMessage() {}

func (x *GraphProto) ProtoReflect() protoreflect.Message {
	mi := &file_zonnx_internal_onnx_onnx_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GraphProto.ProtoReflect.Descriptor instead.
func (*GraphProto) Descriptor() ([]byte, []int) {
	return file_zonnx_internal_onnx_onnx_proto_rawDescGZIP(), []int{13}
}

func (x *GraphProto) GetNode() []*NodeProto {
	if x != nil {
		return x.Node
	}
	return nil
}

func (x *GraphProto) GetName() string {
	if x != nil && x.Name != nil {
		return *x.Name
	}
	return ""
}

func (x *GraphProto) GetInitializer() []*TensorProto {
	if x != nil {
		return x.Initializer
	}
	return nil
}

func (x *GraphProto) GetSparseInitializer() []*SparseTensorProto {
	if x != nil {
		return x.SparseInitializer
	}
	return nil
}

func (x *GraphProto) GetDocString() string {
	if x != nil && x.DocString != nil {
		return *x.DocString
	}
	return ""
}

func (x *GraphProto) GetInput() []*ValueInfoProto {
	if x != nil {
		return x.Input
	}
	return nil
}

func (x *GraphProto) GetOutput() []*ValueInfoProto {
	if x != nil {
		return x.Output
	}
	return nil
}

func (x *GraphProto) GetValueInfo() []*ValueInfoProto {
	if x != nil {
		return x.ValueInfo
	}
	return nil
}

func (x *GraphProto) GetQuantizationAnnotation() []*TensorAnnotation {
	if x != nil {
		return x.QuantizationAnnotation
	}
	return nil
}

func (x *GraphProto) GetMetadataProps() []*StringStringEntryProto {
	if x != nil {
		return x.MetadataProps
	}
	return nil
}

// Tensors
//
// A serialized tensor value.
type TensorProto struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The shape of the tensor.
	Dims []int64 `protobuf:"varint,1,rep,name=dims" json:"dims,omitempty"`
	// The data type of the tensor.
	// This field MUST have a valid TensorProto.DataType value
	DataType *int32               `protobuf:"varint,2,opt,name=data_type,json=dataType" json:"data_type,omitempty"`
	Segment  *TensorProto_Segment `protobuf:"bytes,3,opt,name=segment" json:"segment,omitempty"`
	// For float and complex64 values
	// Complex64 tensors are encoded as a single array of floats,
	// with the real components appearing in odd numbered positions,
	// and the corresponding imaginary component appearing in the
	// subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
	// is encoded as [1.0, 2.0 ,3.0 ,4.0]
	// When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
	FloatData []float32 `protobuf:"fixed32,4,rep,packed,name=float_data,json=floatData" json:"float_data,omitempty"`
	// For int32, uint8, int8, uint16, int16, uint4, int4, bool, (b)float16, float8, and float4:
	//   - (b)float16 and float8 values MUST be converted bit-wise into an unsigned integer
	//     representation before being written to the buffer.
	//   - Each pair of uint4, int4, and float4 values MUST be packed as two 4-bit elements into a single byte.
	//     The first element is stored in the 4 least significant bits (LSB),
	//     and the second element is stored in the 4 most significant bits (MSB).
	//
	// Consequently:
	// - For data types with a bit-width of 8 or greater, each `int32_data` stores one element.
	// - For 4-bit data types, each `int32_data` stores two elements.
	//
	// When this field is present, the data_type field MUST be
	// INT32, INT16, INT8, INT4, UINT16, UINT8, UINT4, BOOL, FLOAT16, BFLOAT16, FLOAT8E4M3FN, FLOAT8E4M3FNUZ, FLOAT8E5M2, FLOAT8E5M2FNUZ, FLOAT8E8M0, FLOAT4E2M1
	Int32Data []int32 `protobuf:"varint,5,rep,packed,name=int32_data,json=int32Data" json:"int32_data,omitempty"`
	// For strings.
	// Each element of string_data is a UTF-8 encoded Unicode
	// string. No trailing null, no leading BOM. The protobuf "string"
	// scalar type is not used to match ML community conventions.
	// When this field is present, the data_type field MUST be STRING
	StringData [][]byte `protobuf:"bytes,6,rep,name=string_data,json=stringData" json:"string_data,omitempty"`
	// For int64.
	// When this field is present, the data_type field MUST be INT64
	Int64Data []int64 `protobuf:"varint,7,rep,packed,name=int64_data,json=int64Data" json:"int64_data,omitempty"`
	// Optionally, a name for the tensor.
	Name *string `protobuf:"bytes,8,opt,name=name" json:"name,omitempty"` // namespace Value
	// A human-readable documentation for this tensor. Markdown is allowed.
	DocString *string `protobuf:"bytes,12,opt,name=doc_string,json=docString" json:"doc_string,omitempty"`
	// Serializations can either use one of the fields above, or use this
	// raw bytes field. The only exception is the string case, where one is
	// required to store the content in the repeated bytes string_data field.
	//
	// When this raw_data field is used to store tensor value, elements MUST
	// be stored in as fixed-width, little-endian order.
	// Floating-point data types MUST be stored in IEEE 754 format.
	// Complex64 elements must be written as two consecutive FLOAT values, real component first.
	// Complex128 elements must be written as two consecutive DOUBLE values, real component first.
	// Boolean type MUST be written one byte per tensor element (00000001 for true, 00000000 for false).
	// uint4 and int4 values must be packed to 4bitx2, the first element is stored in the 4 LSB and the second element is stored in the 4 MSB.
	//
	// Note: the advantage of specific field rather than the raw_data field is
	// that in some cases (e.g. int data), protobuf does a better packing via
	// variable length storage, and may lead to smaller binary footprint.
	// When this field is present, the data_type field MUST NOT be STRING or UNDEFINED
	RawData []byte `protobuf:"bytes,9,opt,name=raw_data,json=rawData" json:"raw_data,omitempty"`
	// Data can be stored inside the protobuf file using type-specific fields or raw_data.
	// Alternatively, raw bytes data can be stored in an external file, using the external_data field.
	// external_data stores key-value pairs describing data location. Recognized keys are:
	//   - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
	//     protobuf model was stored
	//   - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
	//     Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
	//   - "length" (optional) - number of bytes containing data. Integer stored as string.
	//   - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
	ExternalData []*StringStringEntryProto `protobuf:"bytes,13,rep,name=external_data,json=externalData" json:"external_data,omitempty"`
	// If value not set, data is stored in raw_data (if set) otherwise in type-specified field.
	DataLocation *TensorProto_DataLocation `protobuf:"varint,14,opt,name=data_location,json=dataLocation,enum=onnx.TensorProto_DataLocation" json:"data_location,omitempty"`
	// For double
	// Complex128 tensors are encoded as a single array of doubles,
	// with the real components appearing in odd numbered positions,
	// and the corresponding imaginary component appearing in the
	// subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
	// is encoded as [1.0, 2.0 ,3.0 ,4.0]
	// When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
	DoubleData []float64 `protobuf:"fixed64,10,rep,packed,name=double_data,json=doubleData" json:"double_data,omitempty"`
	// For uint64 and uint32 values
	// When this field is present, the data_type field MUST be
	// UINT32 or UINT64
	Uint64Data []uint64 `protobuf:"varint,11,rep,packed,name=uint64_data,json=uint64Data" json:"uint64_data,omitempty"`
	// Named metadata values; keys should be distinct.
	MetadataProps []*StringStringEntryProto `protobuf:"bytes,16,rep,name=metadata_props,json=metadataProps" json:"metadata_props,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TensorProto) Reset() {
	*x = TensorProto{}
	mi := &file_zonnx_internal_onnx_onnx_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TensorProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TensorProto) ProtoMessage() {}

func (x *TensorProto) ProtoReflect() protoreflect.Message {
	mi := &file_zonnx_internal_onnx_onnx_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TensorProto.ProtoReflect.Descriptor instead.
func (*TensorProto) Descriptor() ([]byte, []int) {
	return file_zonnx_internal_onnx_onnx_proto_rawDescGZIP(), []int{14}
}

func (x *TensorProto) GetDims() []int64 {
	if x != nil {
		return x.Dims
	}
	return nil
}

func (x *TensorProto) GetDataType() int32 {
	if x != nil && x.DataType != nil {
		return *x.DataType
	}
	return 0
}

func (x *TensorProto) GetSegment() *TensorProto_Segment {
	if x != nil {
		return x.Segment
	}
	return nil
}

func (x *TensorProto) GetFloatData() []float32 {
	if x != nil {
		return x.FloatData
	}
	return nil
}

func (x *TensorProto) GetInt32Data() []int32 {
	if x != nil {
		return x.Int32Data
	}
	return nil
}

func (x *TensorProto) GetStringData() [][]byte {
	if x != nil {
		return x.StringData
	}
	return nil
}

func (x *TensorProto) GetInt64Data() []int64 {
	if x != nil {
		return x.Int64Data
	}
	return nil
}

func (x *TensorProto) GetName() string {
	if x != nil && x.Name != nil {
		return *x.Name
	}
	return ""
}

func (x *TensorProto) GetDocString() string {
	if x != nil && x.DocString != nil {
		return *x.DocString
	}
	return ""
}

func (x *TensorProto) GetRawData() []byte {
	if x != nil {
		return x.RawData
	}
	return nil
}

func (x *TensorProto) GetExternalData() []*StringStringEntryProto {
	if x != nil {
		return x.ExternalData
	}
	return nil
}

func (x *TensorProto) GetDataLocation() TensorProto_DataLocation {
	if x != nil && x.DataLocation != nil {
		return *x.DataLocation
	}
	return TensorProto_DEFAULT
}

func (x *TensorProto) GetDoubleData() []float64 {
	if x != nil {
		return x.DoubleData
	}
	return nil
}

func (x *TensorProto) GetUint64Data() []uint64 {
	if x != nil {
		return x.Uint64Data
	}
	return nil
}

func (x *TensorProto) GetMetadataProps() []*StringStringEntryProto {
	if x != nil {
		return x.MetadataProps
	}
	return nil
}

// A serialized sparse-tensor value
type SparseTensorProto struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The sequence of non-default values are encoded as a tensor of shape [NNZ].
	// The default-value is zero for numeric tensors, and empty-string for string tensors.
	// values must have a non-empty name present which serves as a name for SparseTensorProto
	// when used in sparse_initializer list.
	Values *TensorProto `protobuf:"bytes,1,opt,name=values" json:"values,omitempty"`
	// The indices of the non-default values, which may be stored in one of two formats.
	// (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value
	// corresponding to the j-th index of the i-th value (in the values tensor).
	// (b) Indices can be a tensor of shape [NNZ], in which case the i-th value
	// must be the linearized-index of the i-th value (in the values tensor).
	// The linearized-index can be converted into an index tuple (k_1,...,k_rank)
	// using the shape provided below.
	// The indices must appear in ascending order without duplication.
	// In the first format, the ordering is lexicographic-ordering:
	// e.g., index-value [1,4] must appear before [2,1]
	Indices *TensorProto `protobuf:"bytes,2,opt,name=indices" json:"indices,omitempty"`
	// The shape of the underlying dense-tensor: [dim_1, dim_2, ... dim_rank]
	Dims          []int64 `protobuf:"varint,3,rep,name=dims" json:"dims,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SparseTensorProto) Reset() {
	*x = SparseTensorProto{}
	mi := &file_zonnx_internal_onnx_onnx_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SparseTensorProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SparseTensorProto) ProtoMessage() {}

func (x *SparseTensorProto) ProtoReflect() protoreflect.Message {
	mi := &file_zonnx_internal_onnx_onnx_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SparseTensorProto.ProtoReflect.Descriptor instead.
func (*SparseTensorProto) Descriptor() ([]byte, []int) {
	return file_zonnx_internal_onnx_onnx_proto_rawDescGZIP(), []int{15}
}

func (x *SparseTensorProto) GetValues() *TensorProto {
	if x != nil {
		return x.Values
	}
	return nil
}

func (x *SparseTensorProto) GetIndices() *TensorProto {
	if x != nil {
		return x.Indices
	}
	return nil
}

func (x *SparseTensorProto) GetDims() []int64 {
	if x != nil {
		return x.Dims
	}
	return nil
}

// Defines a tensor shape. A dimension can be either an integer value
// or a symbolic variable. A symbolic variable represents an unknown
// dimension.
type TensorShapeProto struct {
	state         protoimpl.MessageState        `protogen:"open.v1"`
	Dim           []*TensorShapeProto_Dimension `protobuf:"bytes,1,rep,name=dim" json:"dim,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TensorShapeProto) Reset() {
	*x = TensorShapeProto{}
	mi := &file_zonnx_internal_onnx_onnx_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TensorShapeProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TensorShapeProto) ProtoMessage() {}

func (x *TensorShapeProto) ProtoReflect() protoreflect.Message {
	mi := &file_zonnx_internal_onnx_onnx_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TensorShapeProto.ProtoReflect.Descriptor instead.
func (*TensorShapeProto) Descriptor() ([]byte, []int) {
	return file_zonnx_internal_onnx_onnx_proto_rawDescGZIP(), []int{16}
}

func (x *TensorShapeProto) GetDim() []*TensorShapeProto_Dimension {
	if x != nil {
		return x.Dim
	}
	return nil
}

// Types
//
// The standard ONNX data types.
type TypeProto struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Value:
	//
	//	*TypeProto_TensorType
	//	*TypeProto_SequenceType
	//	*TypeProto_MapType
	//	*TypeProto_OptionalType
	//	*TypeProto_SparseTensorType
	Value isTypeProto_Value `protobuf_oneof:"value"`
	// An optional denotation can be used to denote the whole
	// type with a standard semantic description as to what is
	// stored inside. Refer to https://github.com/onnx/onnx/blob/main/docs/TypeDenotation.md#type-denotation-definition
	// for pre-defined type denotations.
	Denotation    *string `protobuf:"bytes,6,opt,name=denotation" json:"denotation,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TypeProto) Reset() {
	*x = TypeProto{}
	mi := &file_zonnx_internal_onnx_onnx_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TypeProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TypeProto) ProtoMessage() {}

func (x *TypeProto) ProtoReflect() protoreflect.Message {
	mi := &file_zonnx_internal_onnx_onnx_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TypeProto.ProtoReflect.Descriptor instead.
func (*TypeProto) Descriptor() ([]byte, []int) {
	return file_zonnx_internal_onnx_onnx_proto_rawDescGZIP(), []int{17}
}

func (x *TypeProto) GetValue() isTypeProto_Value {
	if x != nil {
		return x.Value
	}
	return nil
}

func (x *TypeProto) GetTensorType() *TypeProto_Tensor {
	if x != nil {
		if x, ok := x.Value.(*TypeProto_TensorType); ok {
			return x.TensorType
		}
	}
	return nil
}

func (x *TypeProto) GetSequenceType() *TypeProto_Sequence {
	if x != nil {
		if x, ok := x.Value.(*TypeProto_SequenceType); ok {
			return x.SequenceType
		}
	}
	return nil
}

func (x *TypeProto) GetMapType() *TypeProto_Map {
	if x != nil {
		if x, ok := x.Value.(*TypeProto_MapType); ok {
			return x.MapType
		}
	}
	return nil
}

func (x *TypeProto) GetOptionalType() *TypeProto_Optional {
	if x != nil {
		if x, ok := x.Value.(*TypeProto_OptionalType); ok {
			return x.OptionalType
		}
	}
	return nil
}

func (x *TypeProto) GetSparseTensorType() *TypeProto_SparseTensor {
	if x != nil {
		if x, ok := x.Value.(*TypeProto_SparseTensorType); ok {
			return x.SparseTensorType
		}
	}
	return nil
}

func (x *TypeProto) GetDenotation() string {
	if x != nil && x.Denotation != nil {
		return *x.Denotation
	}
	return ""
}

type isTypeProto_Value interface {
	isTypeProto_Value()
}

type TypeProto_TensorType struct {
	// The type of a tensor.
	TensorType *TypeProto_Tensor `protobuf:"bytes,1,opt,name=tensor_type,json=tensorType,oneof"`
}

type TypeProto_SequenceType struct {
	// The type of a sequence.
	SequenceType *TypeProto_Sequence `protobuf:"bytes,4,opt,name=sequence_type,json=sequenceType,oneof"`
}

type TypeProto_MapType struct {
	// The type of a map.
	MapType *TypeProto_Map `protobuf:"bytes,5,opt,name=map_type,json=mapType,oneof"`
}

type TypeProto_OptionalType struct {
	// The type of an optional.
	OptionalType *TypeProto_Optional `protobuf:"bytes,9,opt,name=optional_type,json=optionalType,oneof"`
}

type TypeProto_SparseTensorType struct {
	// Type of the sparse tensor
	SparseTensorType *TypeProto_SparseTensor `protobuf:"bytes,8,opt,name=sparse_tensor_type,json=sparseTensorType,oneof"`
}

func (*TypeProto_TensorType) isTypeProto_Value() {}

func (*TypeProto_SequenceType) isTypeProto_Value() {}

func (*TypeProto_MapType) isTypeProto_Value() {}

func (*TypeProto_OptionalType) isTypeProto_Value() {}

func (*TypeProto_SparseTensorType) isTypeProto_Value() {}

// Operator Sets
//
// OperatorSets are uniquely identified by a (domain, opset_version) pair.
type OperatorSetIdProto struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The domain of the operator set being identified.
	// The empty string ("") or absence of this field implies the operator
	// set that is defined as part of the ONNX specification.
	// This field MUST be present in this version of the IR when referring to any other operator set.
	Domain *string `protobuf:"bytes,1,opt,name=domain" json:"domain,omitempty"`
	// The version of the operator set being identified.
	// This field MUST be present in this version of the IR.
	Version       *int64 `protobuf:"varint,2,opt,name=version" json:"version,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OperatorSetIdProto) Reset() {
	*x = OperatorSetIdProto{}
	mi := &file_zonnx_internal_onnx_onnx_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OperatorSetIdProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OperatorSetIdProto) ProtoMessage() {}

func (x *OperatorSetIdProto) ProtoReflect() protoreflect.Message {
	mi := &file_zonnx_internal_onnx_onnx_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OperatorSetIdProto.ProtoReflect.Descriptor instead.
func (*OperatorSetIdProto) Descriptor() ([]byte, []int) {
	return file_zonnx_internal_onnx_onnx_proto_rawDescGZIP(), []int{18}
}

func (x *OperatorSetIdProto) GetDomain() string {
	if x != nil && x.Domain != nil {
		return *x.Domain
	}
	return ""
}

func (x *OperatorSetIdProto) GetVersion() int64 {
	if x != nil && x.Version != nil {
		return *x.Version
	}
	return 0
}

type FunctionProto struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The name of the function, similar to op_type in NodeProto.
	// This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// The inputs and outputs of the function.
	Input  []string `protobuf:"bytes,4,rep,name=input" json:"input,omitempty"`
	Output []string `protobuf:"bytes,5,rep,name=output" json:"output,omitempty"`
	// The attribute parameters of the function.
	// It is for function parameters without default values.
	Attribute []string `protobuf:"bytes,6,rep,name=attribute" json:"attribute,omitempty"`
	// The attribute protos of the function.
	// It is for function attributes with default values.
	// A function attribute shall be represented either as
	// a string attribute or an AttributeProto, not both.
	AttributeProto []*AttributeProto `protobuf:"bytes,11,rep,name=attribute_proto,json=attributeProto" json:"attribute_proto,omitempty"`
	// The nodes in the function.
	Node []*NodeProto `protobuf:"bytes,7,rep,name=node" json:"node,omitempty"`
	// A human-readable documentation for this function. Markdown is allowed.
	DocString   *string               `protobuf:"bytes,8,opt,name=doc_string,json=docString" json:"doc_string,omitempty"`
	OpsetImport []*OperatorSetIdProto `protobuf:"bytes,9,rep,name=opset_import,json=opsetImport" json:"opset_import,omitempty"`
	// The domain which this function belongs to.
	// This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
	Domain *string `protobuf:"bytes,10,opt,name=domain" json:"domain,omitempty"`
	// The overload identifier of the function.
	// This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
	Overload *string `protobuf:"bytes,13,opt,name=overload" json:"overload,omitempty"`
	// Information for the values in the function. The ValueInfoProto.name's
	// must be distinct and refer to names in the function (including inputs,
	// outputs, and intermediate values). It is optional for a value to appear
	// in value_info list.
	ValueInfo []*ValueInfoProto `protobuf:"bytes,12,rep,name=value_info,json=valueInfo" json:"value_info,omitempty"`
	// Named metadata values; keys should be distinct.
	MetadataProps []*StringStringEntryProto `protobuf:"bytes,14,rep,name=metadata_props,json=metadataProps" json:"metadata_props,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FunctionProto) Reset() {
	*x = FunctionProto{}
	mi := &file_zonnx_internal_onnx_onnx_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FunctionProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FunctionProto) ProtoMessage() {}

func (x *FunctionProto) ProtoReflect() protoreflect.Message {
	mi := &file_zonnx_internal_onnx_onnx_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FunctionProto.ProtoReflect.Descriptor instead.
func (*FunctionProto) Descriptor() ([]byte, []int) {
	return file_zonnx_internal_onnx_onnx_proto_rawDescGZIP(), []int{19}
}

func (x *FunctionProto) GetName() string {
	if x != nil && x.Name != nil {
		return *x.Name
	}
	return ""
}

func (x *FunctionProto) GetInput() []string {
	if x != nil {
		return x.Input
	}
	return nil
}

func (x *FunctionProto) GetOutput() []string {
	if x != nil {
		return x.Output
	}
	return nil
}

func (x *FunctionProto) GetAttribute() []string {
	if x != nil {
		return x.Attribute
	}
	return nil
}

func (x *FunctionProto) GetAttributeProto() []*AttributeProto {
	if x != nil {
		return x.AttributeProto
	}
	return nil
}

func (x *FunctionProto) GetNode() []*NodeProto {
	if x != nil {
		return x.Node
	}
	return nil
}

func (x *FunctionProto) GetDocString() string {
	if x != nil && x.DocString != nil {
		return *x.DocString
	}
	return ""
}

func (x *FunctionProto) GetOpsetImport() []*OperatorSetIdProto {
	if x != nil {
		return x.OpsetImport
	}
	return nil
}

func (x *FunctionProto) GetDomain() string {
	if x != nil && x.Domain != nil {
		return *x.Domain
	}
	return ""
}

func (x *FunctionProto) GetOverload() string {
	if x != nil && x.Overload != nil {
		return *x.Overload
	}
	return ""
}

func (x *FunctionProto) GetValueInfo() []*ValueInfoProto {
	if x != nil {
		return x.ValueInfo
	}
	return nil
}

func (x *FunctionProto) GetMetadataProps() []*StringStringEntryProto {
	if x != nil {
		return x.MetadataProps
	}
	return nil
}

// For very large tensors, we may want to store them in chunks, in which
// case the following fields will specify the segment that is stored in
// the current TensorProto.
type TensorProto_Segment struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Begin         *int64                 `protobuf:"varint,1,opt,name=begin" json:"begin,omitempty"`
	End           *int64                 `protobuf:"varint,2,opt,name=end" json:"end,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TensorProto_Segment) Reset() {
	*x = TensorProto_Segment{}
	mi := &file_zonnx_internal_onnx_onnx_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TensorProto_Segment) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TensorProto_Segment) ProtoMessage() {}

func (x *TensorProto_Segment) ProtoReflect() protoreflect.Message {
	mi := &file_zonnx_internal_onnx_onnx_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TensorProto_Segment.ProtoReflect.Descriptor instead.
func (*TensorProto_Segment) Descriptor() ([]byte, []int) {
	return file_zonnx_internal_onnx_onnx_proto_rawDescGZIP(), []int{14, 0}
}

func (x *TensorProto_Segment) GetBegin() int64 {
	if x != nil && x.Begin != nil {
		return *x.Begin
	}
	return 0
}

func (x *TensorProto_Segment) GetEnd() int64 {
	if x != nil && x.End != nil {
		return *x.End
	}
	return 0
}

type TensorShapeProto_Dimension struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Value:
	//
	//	*TensorShapeProto_Dimension_DimValue
	//	*TensorShapeProto_Dimension_DimParam
	Value isTensorShapeProto_Dimension_Value `protobuf_oneof:"value"`
	// Standard denotation can optionally be used to denote tensor
	// dimensions with standard semantic descriptions to ensure
	// that operations are applied to the correct axis of a tensor.
	// Refer to https://github.com/onnx/onnx/blob/main/docs/DimensionDenotation.md#denotation-definition
	// for pre-defined dimension denotations.
	Denotation    *string `protobuf:"bytes,3,opt,name=denotation" json:"denotation,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TensorShapeProto_Dimension) Reset() {
	*x = TensorShapeProto_Dimension{}
	mi := &file_zonnx_internal_onnx_onnx_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TensorShapeProto_Dimension) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TensorShapeProto_Dimension) ProtoMessage() {}

func (x *TensorShapeProto_Dimension) ProtoReflect() protoreflect.Message {
	mi := &file_zonnx_internal_onnx_onnx_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TensorShapeProto_Dimension.ProtoReflect.Descriptor instead.
func (*TensorShapeProto_Dimension) Descriptor() ([]byte, []int) {
	return file_zonnx_internal_onnx_onnx_proto_rawDescGZIP(), []int{16, 0}
}

func (x *TensorShapeProto_Dimension) GetValue() isTensorShapeProto_Dimension_Value {
	if x != nil {
		return x.Value
	}
	return nil
}

func (x *TensorShapeProto_Dimension) GetDimValue() int64 {
	if x != nil {
		if x, ok := x.Value.(*TensorShapeProto_Dimension_DimValue); ok {
			return x.DimValue
		}
	}
	return 0
}

func (x *TensorShapeProto_Dimension) GetDimParam() string {
	if x != nil {
		if x, ok := x.Value.(*TensorShapeProto_Dimension_DimParam); ok {
			return x.DimParam
		}
	}
	return ""
}

func (x *TensorShapeProto_Dimension) GetDenotation() string {
	if x != nil && x.Denotation != nil {
		return *x.Denotation
	}
	return ""
}

type isTensorShapeProto_Dimension_Value interface {
	isTensorShapeProto_Dimension_Value()
}

type TensorShapeProto_Dimension_DimValue struct {
	DimValue int64 `protobuf:"varint,1,opt,name=dim_value,json=dimValue,oneof"`
}

type TensorShapeProto_Dimension_DimParam struct {
	DimParam string `protobuf:"bytes,2,opt,name=dim_param,json=dimParam,oneof"` // namespace Shape
}

func (*TensorShapeProto_Dimension_DimValue) isTensorShapeProto_Dimension_Value() {}

func (*TensorShapeProto_Dimension_DimParam) isTensorShapeProto_Dimension_Value() {}

type TypeProto_Tensor struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// This field MUST NOT have the value of UNDEFINED
	// This field MUST have a valid TensorProto.DataType value
	// This field MUST be present for this version of the IR.
	ElemType      *int32            `protobuf:"varint,1,opt,name=elem_type,json=elemType" json:"elem_type,omitempty"`
	Shape         *TensorShapeProto `protobuf:"bytes,2,opt,name=shape" json:"shape,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TypeProto_Tensor) Reset() {
	*x = TypeProto_Tensor{}
	mi := &file_zonnx_internal_onnx_onnx_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TypeProto_Tensor) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TypeProto_Tensor) ProtoMessage() {}

func (x *TypeProto_Tensor) ProtoReflect() protoreflect.Message {
	mi := &file_zonnx_internal_onnx_onnx_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TypeProto_Tensor.ProtoReflect.Descriptor instead.
func (*TypeProto_Tensor) Descriptor() ([]byte, []int) {
	return file_zonnx_internal_onnx_onnx_proto_rawDescGZIP(), []int{17, 0}
}

func (x *TypeProto_Tensor) GetElemType() int32 {
	if x != nil && x.ElemType != nil {
		return *x.ElemType
	}
	return 0
}

func (x *TypeProto_Tensor) GetShape() *TensorShapeProto {
	if x != nil {
		return x.Shape
	}
	return nil
}

// repeated T
type TypeProto_Sequence struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The type and optional shape of each element of the sequence.
	// This field MUST be present for this version of the IR.
	ElemType      *TypeProto `protobuf:"bytes,1,opt,name=elem_type,json=elemType" json:"elem_type,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TypeProto_Sequence) Reset() {
	*x = TypeProto_Sequence{}
	mi := &file_zonnx_internal_onnx_onnx_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TypeProto_Sequence) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TypeProto_Sequence) ProtoMessage() {}

func (x *TypeProto_Sequence) ProtoReflect() protoreflect.Message {
	mi := &file_zonnx_internal_onnx_onnx_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TypeProto_Sequence.ProtoReflect.Descriptor instead.
func (*TypeProto_Sequence) Descriptor() ([]byte, []int) {
	return file_zonnx_internal_onnx_onnx_proto_rawDescGZIP(), []int{17, 1}
}

func (x *TypeProto_Sequence) GetElemType() *TypeProto {
	if x != nil {
		return x.ElemType
	}
	return nil
}

// map<K,V>
type TypeProto_Map struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// This field MUST have a valid TensorProto.DataType value
	// This field MUST be present for this version of the IR.
	// This field MUST refer to an integral type ([U]INT{8|16|32|64}) or STRING
	KeyType *int32 `protobuf:"varint,1,opt,name=key_type,json=keyType" json:"key_type,omitempty"`
	// This field MUST be present for this version of the IR.
	ValueType     *TypeProto `protobuf:"bytes,2,opt,name=value_type,json=valueType" json:"value_type,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TypeProto_Map) Reset() {
	*x = TypeProto_Map{}
	mi := &file_zonnx_internal_onnx_onnx_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TypeProto_Map) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TypeProto_Map) ProtoMessage() {}

func (x *TypeProto_Map) ProtoReflect() protoreflect.Message {
	mi := &file_zonnx_internal_onnx_onnx_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TypeProto_Map.ProtoReflect.Descriptor instead.
func (*TypeProto_Map) Descriptor() ([]byte, []int) {
	return file_zonnx_internal_onnx_onnx_proto_rawDescGZIP(), []int{17, 2}
}

func (x *TypeProto_Map) GetKeyType() int32 {
	if x != nil && x.KeyType != nil {
		return *x.KeyType
	}
	return 0
}

func (x *TypeProto_Map) GetValueType() *TypeProto {
	if x != nil {
		return x.ValueType
	}
	return nil
}

// wrapper for Tensor, Sequence, or Map
type TypeProto_Optional struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The type and optional shape of the element wrapped.
	// This field MUST be present for this version of the IR.
	// Possible values correspond to OptionalProto.DataType enum
	ElemType      *TypeProto `protobuf:"bytes,1,opt,name=elem_type,json=elemType" json:"elem_type,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TypeProto_Optional) Reset() {
	*x = TypeProto_Optional{}
	mi := &file_zonnx_internal_onnx_onnx_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TypeProto_Optional) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TypeProto_Optional) ProtoMessage() {}

func (x *TypeProto_Optional) ProtoReflect() protoreflect.Message {
	mi := &file_zonnx_internal_onnx_onnx_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TypeProto_Optional.ProtoReflect.Descriptor instead.
func (*TypeProto_Optional) Descriptor() ([]byte, []int) {
	return file_zonnx_internal_onnx_onnx_proto_rawDescGZIP(), []int{17, 3}
}

func (x *TypeProto_Optional) GetElemType() *TypeProto {
	if x != nil {
		return x.ElemType
	}
	return nil
}

type TypeProto_SparseTensor struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// This field MUST NOT have the value of UNDEFINED
	// This field MUST have a valid TensorProto.DataType value
	// This field MUST be present for this version of the IR.
	ElemType      *int32            `protobuf:"varint,1,opt,name=elem_type,json=elemType" json:"elem_type,omitempty"`
	Shape         *TensorShapeProto `protobuf:"bytes,2,opt,name=shape" json:"shape,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TypeProto_SparseTensor) Reset() {
	*x = TypeProto_SparseTensor{}
	mi := &file_zonnx_internal_onnx_onnx_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TypeProto_SparseTensor) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TypeProto_SparseTensor) ProtoMessage() {}

func (x *TypeProto_SparseTensor) ProtoReflect() protoreflect.Message {
	mi := &file_zonnx_internal_onnx_onnx_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TypeProto_SparseTensor.ProtoReflect.Descriptor instead.
func (*TypeProto_SparseTensor) Descriptor() ([]byte, []int) {
	return file_zonnx_internal_onnx_onnx_proto_rawDescGZIP(), []int{17, 4}
}

func (x *TypeProto_SparseTensor) GetElemType() int32 {
	if x != nil && x.ElemType != nil {
		return *x.ElemType
	}
	return 0
}

func (x *TypeProto_SparseTensor) GetShape() *TensorShapeProto {
	if x != nil {
		return x.Shape
	}
	return nil
}

var File_zonnx_internal_onnx_onnx_proto protoreflect.FileDescriptor

const file_zonnx_internal_onnx_onnx_proto_rawDesc = "" +
	"\n" +
	"\x1ezonnx/internal/onnx/onnx.proto\x12\x04onnx\"\xe3\x06\n" +
	"\x0eAttributeProto\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\"\n" +
	"\rref_attr_name\x18\x15 \x01(\tR\vrefAttrName\x12\x1d\n" +
	"\n" +
	"doc_string\x18\r \x01(\tR\tdocString\x126\n" +
	"\x04type\x18\x14 \x01(\x0e2\".onnx.AttributeProto.AttributeTypeR\x04type\x12\f\n" +
	"\x01f\x18\x02 \x01(\x02R\x01f\x12\f\n" +
	"\x01i\x18\x03 \x01(\x03R\x01i\x12\f\n" +
	"\x01s\x18\x04 \x01(\fR\x01s\x12\x1f\n" +
	"\x01t\x18\x05 \x01(\v2\x11.onnx.TensorProtoR\x01t\x12\x1e\n" +
	"\x01g\x18\x06 \x01(\v2\x10.onnx.GraphProtoR\x01g\x12<\n" +
	"\rsparse_tensor\x18\x16 \x01(\v2\x17.onnx.SparseTensorProtoR\fsparseTensor\x12\x1f\n" +
	"\x02tp\x18\x0e \x01(\v2\x0f.onnx.TypeProtoR\x02tp\x12\x16\n" +
	"\x06floats\x18\a \x03(\x02R\x06floats\x12\x12\n" +
	"\x04ints\x18\b \x03(\x03R\x04ints\x12\x18\n" +
	"\astrings\x18\t \x03(\fR\astrings\x12+\n" +
	"\atensors\x18\n" +
	" \x03(\v2\x11.onnx.TensorProtoR\atensors\x12(\n" +
	"\x06graphs\x18\v \x03(\v2\x10.onnx.GraphProtoR\x06graphs\x12>\n" +
	"\x0esparse_tensors\x18\x17 \x03(\v2\x17.onnx.SparseTensorProtoR\rsparseTensors\x120\n" +
	"\vtype_protos\x18\x0f \x03(\v2\x0f.onnx.TypeProtoR\n" +
	"typeProtos\"\xd9\x01\n" +
	"\rAttributeType\x12\r\n" +
	"\tUNDEFINED\x10\x00\x12\t\n" +
	"\x05FLOAT\x10\x01\x12\a\n" +
	"\x03INT\x10\x02\x12\n" +
	"\n" +
	"\x06STRING\x10\x03\x12\n" +
	"\n" +
	"\x06TENSOR\x10\x04\x12\t\n" +
	"\x05GRAPH\x10\x05\x12\x11\n" +
	"\rSPARSE_TENSOR\x10\v\x12\x0e\n" +
	"\n" +
	"TYPE_PROTO\x10\r\x12\n" +
	"\n" +
	"\x06FLOATS\x10\x06\x12\b\n" +
	"\x04INTS\x10\a\x12\v\n" +
	"\aSTRINGS\x10\b\x12\v\n" +
	"\aTENSORS\x10\t\x12\n" +
	"\n" +
	"\x06GRAPHS\x10\n" +
	"\x12\x12\n" +
	"\x0eSPARSE_TENSORS\x10\f\x12\x0f\n" +
	"\vTYPE_PROTOS\x10\x0eJ\x04\b\f\x10\rJ\x04\b\x10\x10\x14R\x01v\"\xad\x01\n" +
	"\x0eValueInfoProto\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12#\n" +
	"\x04type\x18\x02 \x01(\v2\x0f.onnx.TypeProtoR\x04type\x12\x1d\n" +
	"\n" +
	"doc_string\x18\x03 \x01(\tR\tdocString\x12C\n" +
	"\x0emetadata_props\x18\x04 \x03(\v2\x1c.onnx.StringStringEntryProtoR\rmetadataProps\"\x8b\x03\n" +
	"\tNodeProto\x12\x14\n" +
	"\x05input\x18\x01 \x03(\tR\x05input\x12\x16\n" +
	"\x06output\x18\x02 \x03(\tR\x06output\x12\x12\n" +
	"\x04name\x18\x03 \x01(\tR\x04name\x12\x17\n" +
	"\aop_type\x18\x04 \x01(\tR\x06opType\x12\x16\n" +
	"\x06domain\x18\a \x01(\tR\x06domain\x12\x1a\n" +
	"\boverload\x18\b \x01(\tR\boverload\x122\n" +
	"\tattribute\x18\x05 \x03(\v2\x14.onnx.AttributeProtoR\tattribute\x12\x1d\n" +
	"\n" +
	"doc_string\x18\x06 \x01(\tR\tdocString\x12C\n" +
	"\x0emetadata_props\x18\t \x03(\v2\x1c.onnx.StringStringEntryProtoR\rmetadataProps\x12W\n" +
	"\x15device_configurations\x18\n" +
	" \x03(\v2\".onnx.NodeDeviceConfigurationProtoR\x14deviceConfigurations\">\n" +
	"\x14IntIntListEntryProto\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x03R\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x03(\x03R\x05value\"\xae\x01\n" +
	"\x1cNodeDeviceConfigurationProto\x12)\n" +
	"\x10configuration_id\x18\x01 \x01(\tR\x0fconfigurationId\x12<\n" +
	"\rsharding_spec\x18\x02 \x03(\v2\x17.onnx.ShardingSpecProtoR\fshardingSpec\x12%\n" +
	"\x0epipeline_stage\x18\x03 \x01(\x05R\rpipelineStage\"\xda\x01\n" +
	"\x11ShardingSpecProto\x12\x1f\n" +
	"\vtensor_name\x18\x01 \x01(\tR\n" +
	"tensorName\x12\x16\n" +
	"\x06device\x18\x02 \x03(\x03R\x06device\x12T\n" +
	"\x19index_to_device_group_map\x18\x03 \x03(\v2\x1a.onnx.IntIntListEntryProtoR\x15indexToDeviceGroupMap\x126\n" +
	"\vsharded_dim\x18\x04 \x03(\v2\x15.onnx.ShardedDimProtoR\n" +
	"shardedDim\"k\n" +
	"\x0fShardedDimProto\x12\x12\n" +
	"\x04axis\x18\x01 \x01(\x03R\x04axis\x12D\n" +
	"\x0fsimple_sharding\x18\x02 \x03(\v2\x1b.onnx.SimpleShardedDimProtoR\x0esimpleSharding\"{\n" +
	"\x15SimpleShardedDimProto\x12\x1d\n" +
	"\tdim_value\x18\x01 \x01(\x03H\x00R\bdimValue\x12\x1d\n" +
	"\tdim_param\x18\x02 \x01(\tH\x00R\bdimParam\x12\x1d\n" +
	"\n" +
	"num_shards\x18\x03 \x01(\x03R\tnumShardsB\x05\n" +
	"\x03dim\"\x97\x02\n" +
	"\x11TrainingInfoProto\x128\n" +
	"\x0einitialization\x18\x01 \x01(\v2\x10.onnx.GraphProtoR\x0einitialization\x12.\n" +
	"\talgorithm\x18\x02 \x01(\v2\x10.onnx.GraphProtoR\talgorithm\x12S\n" +
	"\x16initialization_binding\x18\x03 \x03(\v2\x1c.onnx.StringStringEntryProtoR\x15initializationBinding\x12C\n" +
	"\x0eupdate_binding\x18\x04 \x03(\v2\x1c.onnx.StringStringEntryProtoR\rupdateBinding\"\xb8\x04\n" +
	"\n" +
	"ModelProto\x12\x1d\n" +
	"\n" +
	"ir_version\x18\x01 \x01(\x03R\tirVersion\x12;\n" +
	"\fopset_import\x18\b \x03(\v2\x18.onnx.OperatorSetIdProtoR\vopsetImport\x12#\n" +
	"\rproducer_name\x18\x02 \x01(\tR\fproducerName\x12)\n" +
	"\x10producer_version\x18\x03 \x01(\tR\x0fproducerVersion\x12\x16\n" +
	"\x06domain\x18\x04 \x01(\tR\x06domain\x12#\n" +
	"\rmodel_version\x18\x05 \x01(\x03R\fmodelVersion\x12\x1d\n" +
	"\n" +
	"doc_string\x18\x06 \x01(\tR\tdocString\x12&\n" +
	"\x05graph\x18\a \x01(\v2\x10.onnx.GraphProtoR\x05graph\x12C\n" +
	"\x0emetadata_props\x18\x0e \x03(\v2\x1c.onnx.StringStringEntryProtoR\rmetadataProps\x12<\n" +
	"\rtraining_info\x18\x14 \x03(\v2\x17.onnx.TrainingInfoProtoR\ftrainingInfo\x121\n" +
	"\tfunctions\x18\x19 \x03(\v2\x13.onnx.FunctionProtoR\tfunctions\x12D\n" +
	"\rconfiguration\x18\x1a \x03(\v2\x1e.onnx.DeviceConfigurationProtoR\rconfiguration\"g\n" +
	"\x18DeviceConfigurationProto\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x1f\n" +
	"\vnum_devices\x18\x02 \x01(\x05R\n" +
	"numDevices\x12\x16\n" +
	"\x06device\x18\x03 \x03(\tR\x06device\"@\n" +
	"\x16StringStringEntryProto\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value\"\x92\x01\n" +
	"\x10TensorAnnotation\x12\x1f\n" +
	"\vtensor_name\x18\x01 \x01(\tR\n" +
	"tensorName\x12]\n" +
	"\x1cquant_parameter_tensor_names\x18\x02 \x03(\v2\x1c.onnx.StringStringEntryProtoR\x19quantParameterTensorNames\"\xcc\x04\n" +
	"\n" +
	"GraphProto\x12#\n" +
	"\x04node\x18\x01 \x03(\v2\x0f.onnx.NodeProtoR\x04node\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x123\n" +
	"\vinitializer\x18\x05 \x03(\v2\x11.onnx.TensorProtoR\vinitializer\x12F\n" +
	"\x12sparse_initializer\x18\x0f \x03(\v2\x17.onnx.SparseTensorProtoR\x11sparseInitializer\x12\x1d\n" +
	"\n" +
	"doc_string\x18\n" +
	" \x01(\tR\tdocString\x12*\n" +
	"\x05input\x18\v \x03(\v2\x14.onnx.ValueInfoProtoR\x05input\x12,\n" +
	"\x06output\x18\f \x03(\v2\x14.onnx.ValueInfoProtoR\x06output\x123\n" +
	"\n" +
	"value_info\x18\r \x03(\v2\x14.onnx.ValueInfoProtoR\tvalueInfo\x12O\n" +
	"\x17quantization_annotation\x18\x0e \x03(\v2\x16.onnx.TensorAnnotationR\x16quantizationAnnotation\x12C\n" +
	"\x0emetadata_props\x18\x10 \x03(\v2\x1c.onnx.StringStringEntryProtoR\rmetadataPropsJ\x04\b\x03\x10\x04J\x04\b\x04\x10\x05J\x04\b\x06\x10\n" +
	"R\n" +
	"ir_versionR\x10producer_versionR\fproducer_tagR\x06domain\"\x9c\b\n" +
	"\vTensorProto\x12\x12\n" +
	"\x04dims\x18\x01 \x03(\x03R\x04dims\x12\x1b\n" +
	"\tdata_type\x18\x02 \x01(\x05R\bdataType\x123\n" +
	"\asegment\x18\x03 \x01(\v2\x19.onnx.TensorProto.SegmentR\asegment\x12!\n" +
	"\n" +
	"float_data\x18\x04 \x03(\x02B\x02\x10\x01R\tfloatData\x12!\n" +
	"\n" +
	"int32_data\x18\x05 \x03(\x05B\x02\x10\x01R\tint32Data\x12\x1f\n" +
	"\vstring_data\x18\x06 \x03(\fR\n" +
	"stringData\x12!\n" +
	"\n" +
	"int64_data\x18\a \x03(\x03B\x02\x10\x01R\tint64Data\x12\x12\n" +
	"\x04name\x18\b \x01(\tR\x04name\x12\x1d\n" +
	"\n" +
	"doc_string\x18\f \x01(\tR\tdocString\x12\x19\n" +
	"\braw_data\x18\t \x01(\fR\arawData\x12A\n" +
	"\rexternal_data\x18\r \x03(\v2\x1c.onnx.StringStringEntryProtoR\fexternalData\x12C\n" +
	"\rdata_location\x18\x0e \x01(\x0e2\x1e.onnx.TensorProto.DataLocationR\fdataLocation\x12#\n" +
	"\vdouble_data\x18\n" +
	" \x03(\x01B\x02\x10\x01R\n" +
	"doubleData\x12#\n" +
	"\vuint64_data\x18\v \x03(\x04B\x02\x10\x01R\n" +
	"uint64Data\x12C\n" +
	"\x0emetadata_props\x18\x10 \x03(\v2\x1c.onnx.StringStringEntryProtoR\rmetadataProps\x1a1\n" +
	"\aSegment\x12\x14\n" +
	"\x05begin\x18\x01 \x01(\x03R\x05begin\x12\x10\n" +
	"\x03end\x18\x02 \x01(\x03R\x03end\"\xd9\x02\n" +
	"\bDataType\x12\r\n" +
	"\tUNDEFINED\x10\x00\x12\t\n" +
	"\x05FLOAT\x10\x01\x12\t\n" +
	"\x05UINT8\x10\x02\x12\b\n" +
	"\x04INT8\x10\x03\x12\n" +
	"\n" +
	"\x06UINT16\x10\x04\x12\t\n" +
	"\x05INT16\x10\x05\x12\t\n" +
	"\x05INT32\x10\x06\x12\t\n" +
	"\x05INT64\x10\a\x12\n" +
	"\n" +
	"\x06STRING\x10\b\x12\b\n" +
	"\x04BOOL\x10\t\x12\v\n" +
	"\aFLOAT16\x10\n" +
	"\x12\n" +
	"\n" +
	"\x06DOUBLE\x10\v\x12\n" +
	"\n" +
	"\x06UINT32\x10\f\x12\n" +
	"\n" +
	"\x06UINT64\x10\r\x12\r\n" +
	"\tCOMPLEX64\x10\x0e\x12\x0e\n" +
	"\n" +
	"COMPLEX128\x10\x0f\x12\f\n" +
	"\bBFLOAT16\x10\x10\x12\x10\n" +
	"\fFLOAT8E4M3FN\x10\x11\x12\x12\n" +
	"\x0eFLOAT8E4M3FNUZ\x10\x12\x12\x0e\n" +
	"\n" +
	"FLOAT8E5M2\x10\x13\x12\x12\n" +
	"\x0eFLOAT8E5M2FNUZ\x10\x14\x12\t\n" +
	"\x05UINT4\x10\x15\x12\b\n" +
	"\x04INT4\x10\x16\x12\x0e\n" +
	"\n" +
	"FLOAT4E2M1\x10\x17\x12\x0e\n" +
	"\n" +
	"FLOAT8E8M0\x10\x18\")\n" +
	"\fDataLocation\x12\v\n" +
	"\aDEFAULT\x10\x00\x12\f\n" +
	"\bEXTERNAL\x10\x01\"\x7f\n" +
	"\x11SparseTensorProto\x12)\n" +
	"\x06values\x18\x01 \x01(\v2\x11.onnx.TensorProtoR\x06values\x12+\n" +
	"\aindices\x18\x02 \x01(\v2\x11.onnx.TensorProtoR\aindices\x12\x12\n" +
	"\x04dims\x18\x03 \x03(\x03R\x04dims\"\xba\x01\n" +
	"\x10TensorShapeProto\x122\n" +
	"\x03dim\x18\x01 \x03(\v2 .onnx.TensorShapeProto.DimensionR\x03dim\x1ar\n" +
	"\tDimension\x12\x1d\n" +
	"\tdim_value\x18\x01 \x01(\x03H\x00R\bdimValue\x12\x1d\n" +
	"\tdim_param\x18\x02 \x01(\tH\x00R\bdimParam\x12\x1e\n" +
	"\n" +
	"denotation\x18\x03 \x01(\tR\n" +
	"denotationB\a\n" +
	"\x05value\"\xe7\x05\n" +
	"\tTypeProto\x129\n" +
	"\vtensor_type\x18\x01 \x01(\v2\x16.onnx.TypeProto.TensorH\x00R\n" +
	"tensorType\x12?\n" +
	"\rsequence_type\x18\x04 \x01(\v2\x18.onnx.TypeProto.SequenceH\x00R\fsequenceType\x120\n" +
	"\bmap_type\x18\x05 \x01(\v2\x13.onnx.TypeProto.MapH\x00R\amapType\x12?\n" +
	"\roptional_type\x18\t \x01(\v2\x18.onnx.TypeProto.OptionalH\x00R\foptionalType\x12L\n" +
	"\x12sparse_tensor_type\x18\b \x01(\v2\x1c.onnx.TypeProto.SparseTensorH\x00R\x10sparseTensorType\x12\x1e\n" +
	"\n" +
	"denotation\x18\x06 \x01(\tR\n" +
	"denotation\x1aS\n" +
	"\x06Tensor\x12\x1b\n" +
	"\telem_type\x18\x01 \x01(\x05R\belemType\x12,\n" +
	"\x05shape\x18\x02 \x01(\v2\x16.onnx.TensorShapeProtoR\x05shape\x1a8\n" +
	"\bSequence\x12,\n" +
	"\telem_type\x18\x01 \x01(\v2\x0f.onnx.TypeProtoR\belemType\x1aP\n" +
	"\x03Map\x12\x19\n" +
	"\bkey_type\x18\x01 \x01(\x05R\akeyType\x12.\n" +
	"\n" +
	"value_type\x18\x02 \x01(\v2\x0f.onnx.TypeProtoR\tvalueType\x1a8\n" +
	"\bOptional\x12,\n" +
	"\telem_type\x18\x01 \x01(\v2\x0f.onnx.TypeProtoR\belemType\x1aY\n" +
	"\fSparseTensor\x12\x1b\n" +
	"\telem_type\x18\x01 \x01(\x05R\belemType\x12,\n" +
	"\x05shape\x18\x02 \x01(\v2\x16.onnx.TensorShapeProtoR\x05shapeB\a\n" +
	"\x05value\"F\n" +
	"\x12OperatorSetIdProto\x12\x16\n" +
	"\x06domain\x18\x01 \x01(\tR\x06domain\x12\x18\n" +
	"\aversion\x18\x02 \x01(\x03R\aversion\"\x80\x04\n" +
	"\rFunctionProto\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x14\n" +
	"\x05input\x18\x04 \x03(\tR\x05input\x12\x16\n" +
	"\x06output\x18\x05 \x03(\tR\x06output\x12\x1c\n" +
	"\tattribute\x18\x06 \x03(\tR\tattribute\x12=\n" +
	"\x0fattribute_proto\x18\v \x03(\v2\x14.onnx.AttributeProtoR\x0eattributeProto\x12#\n" +
	"\x04node\x18\a \x03(\v2\x0f.onnx.NodeProtoR\x04node\x12\x1d\n" +
	"\n" +
	"doc_string\x18\b \x01(\tR\tdocString\x12;\n" +
	"\fopset_import\x18\t \x03(\v2\x18.onnx.OperatorSetIdProtoR\vopsetImport\x12\x16\n" +
	"\x06domain\x18\n" +
	" \x01(\tR\x06domain\x12\x1a\n" +
	"\boverload\x18\r \x01(\tR\boverload\x123\n" +
	"\n" +
	"value_info\x18\f \x03(\v2\x14.onnx.ValueInfoProtoR\tvalueInfo\x12C\n" +
	"\x0emetadata_props\x18\x0e \x03(\v2\x1c.onnx.StringStringEntryProtoR\rmetadataPropsJ\x04\b\x02\x10\x03J\x04\b\x03\x10\x04R\rsince_versionR\x06status*\xcc\x02\n" +
	"\aVersion\x12\x12\n" +
	"\x0e_START_VERSION\x10\x00\x12\x19\n" +
	"\x15IR_VERSION_2017_10_10\x10\x01\x12\x19\n" +
	"\x15IR_VERSION_2017_10_30\x10\x02\x12\x18\n" +
	"\x14IR_VERSION_2017_11_3\x10\x03\x12\x18\n" +
	"\x14IR_VERSION_2019_1_22\x10\x04\x12\x18\n" +
	"\x14IR_VERSION_2019_3_18\x10\x05\x12\x18\n" +
	"\x14IR_VERSION_2019_9_19\x10\x06\x12\x17\n" +
	"\x13IR_VERSION_2020_5_8\x10\a\x12\x18\n" +
	"\x14IR_VERSION_2021_7_30\x10\b\x12\x17\n" +
	"\x13IR_VERSION_2023_5_5\x10\t\x12\x18\n" +
	"\x14IR_VERSION_2024_3_25\x10\n" +
	"\x12\x19\n" +
	"\x15IR_VERSION_2025_05_12\x10\v\x12\x0e\n" +
	"\n" +
	"IR_VERSION\x10\f*.\n" +
	"\x0eOperatorStatus\x12\x10\n" +
	"\fEXPERIMENTAL\x10\x00\x12\n" +
	"\n" +
	"\x06STABLE\x10\x01B\x02H\x03"

var (
	file_zonnx_internal_onnx_onnx_proto_rawDescOnce sync.Once
	file_zonnx_internal_onnx_onnx_proto_rawDescData []byte
)

func file_zonnx_internal_onnx_onnx_proto_rawDescGZIP() []byte {
	file_zonnx_internal_onnx_onnx_proto_rawDescOnce.Do(func() {
		file_zonnx_internal_onnx_onnx_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_zonnx_internal_onnx_onnx_proto_rawDesc), len(file_zonnx_internal_onnx_onnx_proto_rawDesc)))
	})
	return file_zonnx_internal_onnx_onnx_proto_rawDescData
}

var file_zonnx_internal_onnx_onnx_proto_enumTypes = make([]protoimpl.EnumInfo, 5)
var file_zonnx_internal_onnx_onnx_proto_msgTypes = make([]protoimpl.MessageInfo, 27)
var file_zonnx_internal_onnx_onnx_proto_goTypes = []any{
	(Version)(0),                         // 0: onnx.Version
	(OperatorStatus)(0),                  // 1: onnx.OperatorStatus
	(AttributeProto_AttributeType)(0),    // 2: onnx.AttributeProto.AttributeType
	(TensorProto_DataType)(0),            // 3: onnx.TensorProto.DataType
	(TensorProto_DataLocation)(0),        // 4: onnx.TensorProto.DataLocation
	(*AttributeProto)(nil),               // 5: onnx.AttributeProto
	(*ValueInfoProto)(nil),               // 6: onnx.ValueInfoProto
	(*NodeProto)(nil),                    // 7: onnx.NodeProto
	(*IntIntListEntryProto)(nil),         // 8: onnx.IntIntListEntryProto
	(*NodeDeviceConfigurationProto)(nil), // 9: onnx.NodeDeviceConfigurationProto
	(*ShardingSpecProto)(nil),            // 10: onnx.ShardingSpecProto
	(*ShardedDimProto)(nil),              // 11: onnx.ShardedDimProto
	(*SimpleShardedDimProto)(nil),        // 12: onnx.SimpleShardedDimProto
	(*TrainingInfoProto)(nil),            // 13: onnx.TrainingInfoProto
	(*ModelProto)(nil),                   // 14: onnx.ModelProto
	(*DeviceConfigurationProto)(nil),     // 15: onnx.DeviceConfigurationProto
	(*StringStringEntryProto)(nil),       // 16: onnx.StringStringEntryProto
	(*TensorAnnotation)(nil),             // 17: onnx.TensorAnnotation
	(*GraphProto)(nil),                   // 18: onnx.GraphProto
	(*TensorProto)(nil),                  // 19: onnx.TensorProto
	(*SparseTensorProto)(nil),            // 20: onnx.SparseTensorProto
	(*TensorShapeProto)(nil),             // 21: onnx.TensorShapeProto
	(*TypeProto)(nil),                    // 22: onnx.TypeProto
	(*OperatorSetIdProto)(nil),           // 23: onnx.OperatorSetIdProto
	(*FunctionProto)(nil),                // 24: onnx.FunctionProto
	(*TensorProto_Segment)(nil),          // 25: onnx.TensorProto.Segment
	(*TensorShapeProto_Dimension)(nil),   // 26: onnx.TensorShapeProto.Dimension
	(*TypeProto_Tensor)(nil),             // 27: onnx.TypeProto.Tensor
	(*TypeProto_Sequence)(nil),           // 28: onnx.TypeProto.Sequence
	(*TypeProto_Map)(nil),                // 29: onnx.TypeProto.Map
	(*TypeProto_Optional)(nil),           // 30: onnx.TypeProto.Optional
	(*TypeProto_SparseTensor)(nil),       // 31: onnx.TypeProto.SparseTensor
}
var file_zonnx_internal_onnx_onnx_proto_depIdxs = []int32{
	2,  // 0: onnx.AttributeProto.type:type_name -> onnx.AttributeProto.AttributeType
	19, // 1: onnx.AttributeProto.t:type_name -> onnx.TensorProto
	18, // 2: onnx.AttributeProto.g:type_name -> onnx.GraphProto
	20, // 3: onnx.AttributeProto.sparse_tensor:type_name -> onnx.SparseTensorProto
	22, // 4: onnx.AttributeProto.tp:type_name -> onnx.TypeProto
	19, // 5: onnx.AttributeProto.tensors:type_name -> onnx.TensorProto
	18, // 6: onnx.AttributeProto.graphs:type_name -> onnx.GraphProto
	20, // 7: onnx.AttributeProto.sparse_tensors:type_name -> onnx.SparseTensorProto
	22, // 8: onnx.AttributeProto.type_protos:type_name -> onnx.TypeProto
	22, // 9: onnx.ValueInfoProto.type:type_name -> onnx.TypeProto
	16, // 10: onnx.ValueInfoProto.metadata_props:type_name -> onnx.StringStringEntryProto
	5,  // 11: onnx.NodeProto.attribute:type_name -> onnx.AttributeProto
	16, // 12: onnx.NodeProto.metadata_props:type_name -> onnx.StringStringEntryProto
	9,  // 13: onnx.NodeProto.device_configurations:type_name -> onnx.NodeDeviceConfigurationProto
	10, // 14: onnx.NodeDeviceConfigurationProto.sharding_spec:type_name -> onnx.ShardingSpecProto
	8,  // 15: onnx.ShardingSpecProto.index_to_device_group_map:type_name -> onnx.IntIntListEntryProto
	11, // 16: onnx.ShardingSpecProto.sharded_dim:type_name -> onnx.ShardedDimProto
	12, // 17: onnx.ShardedDimProto.simple_sharding:type_name -> onnx.SimpleShardedDimProto
	18, // 18: onnx.TrainingInfoProto.initialization:type_name -> onnx.GraphProto
	18, // 19: onnx.TrainingInfoProto.algorithm:type_name -> onnx.GraphProto
	16, // 20: onnx.TrainingInfoProto.initialization_binding:type_name -> onnx.StringStringEntryProto
	16, // 21: onnx.TrainingInfoProto.update_binding:type_name -> onnx.StringStringEntryProto
	23, // 22: onnx.ModelProto.opset_import:type_name -> onnx.OperatorSetIdProto
	18, // 23: onnx.ModelProto.graph:type_name -> onnx.GraphProto
	16, // 24: onnx.ModelProto.metadata_props:type_name -> onnx.StringStringEntryProto
	13, // 25: onnx.ModelProto.training_info:type_name -> onnx.TrainingInfoProto
	24, // 26: onnx.ModelProto.functions:type_name -> onnx.FunctionProto
	15, // 27: onnx.ModelProto.configuration:type_name -> onnx.DeviceConfigurationProto
	16, // 28: onnx.TensorAnnotation.quant_parameter_tensor_names:type_name -> onnx.StringStringEntryProto
	7,  // 29: onnx.GraphProto.node:type_name -> onnx.NodeProto
	19, // 30: onnx.GraphProto.initializer:type_name -> onnx.TensorProto
	20, // 31: onnx.GraphProto.sparse_initializer:type_name -> onnx.SparseTensorProto
	6,  // 32: onnx.GraphProto.input:type_name -> onnx.ValueInfoProto
	6,  // 33: onnx.GraphProto.output:type_name -> onnx.ValueInfoProto
	6,  // 34: onnx.GraphProto.value_info:type_name -> onnx.ValueInfoProto
	17, // 35: onnx.GraphProto.quantization_annotation:type_name -> onnx.TensorAnnotation
	16, // 36: onnx.GraphProto.metadata_props:type_name -> onnx.StringStringEntryProto
	25, // 37: onnx.TensorProto.segment:type_name -> onnx.TensorProto.Segment
	16, // 38: onnx.TensorProto.external_data:type_name -> onnx.StringStringEntryProto
	4,  // 39: onnx.TensorProto.data_location:type_name -> onnx.TensorProto.DataLocation
	16, // 40: onnx.TensorProto.metadata_props:type_name -> onnx.StringStringEntryProto
	19, // 41: onnx.SparseTensorProto.values:type_name -> onnx.TensorProto
	19, // 42: onnx.SparseTensorProto.indices:type_name -> onnx.TensorProto
	26, // 43: onnx.TensorShapeProto.dim:type_name -> onnx.TensorShapeProto.Dimension
	27, // 44: onnx.TypeProto.tensor_type:type_name -> onnx.TypeProto.Tensor
	28, // 45: onnx.TypeProto.sequence_type:type_name -> onnx.TypeProto.Sequence
	29, // 46: onnx.TypeProto.map_type:type_name -> onnx.TypeProto.Map
	30, // 47: onnx.TypeProto.optional_type:type_name -> onnx.TypeProto.Optional
	31, // 48: onnx.TypeProto.sparse_tensor_type:type_name -> onnx.TypeProto.SparseTensor
	5,  // 49: onnx.FunctionProto.attribute_proto:type_name -> onnx.AttributeProto
	7,  // 50: onnx.FunctionProto.node:type_name -> onnx.NodeProto
	23, // 51: onnx.FunctionProto.opset_import:type_name -> onnx.OperatorSetIdProto
	6,  // 52: onnx.FunctionProto.value_info:type_name -> onnx.ValueInfoProto
	16, // 53: onnx.FunctionProto.metadata_props:type_name -> onnx.StringStringEntryProto
	21, // 54: onnx.TypeProto.Tensor.shape:type_name -> onnx.TensorShapeProto
	22, // 55: onnx.TypeProto.Sequence.elem_type:type_name -> onnx.TypeProto
	22, // 56: onnx.TypeProto.Map.value_type:type_name -> onnx.TypeProto
	22, // 57: onnx.TypeProto.Optional.elem_type:type_name -> onnx.TypeProto
	21, // 58: onnx.TypeProto.SparseTensor.shape:type_name -> onnx.TensorShapeProto
	59, // [59:59] is the sub-list for method output_type
	59, // [59:59] is the sub-list for method input_type
	59, // [59:59] is the sub-list for extension type_name
	59, // [59:59] is the sub-list for extension extendee
	0,  // [0:59] is the sub-list for field type_name
}

func init() { file_zonnx_internal_onnx_onnx_proto_init() }
func file_zonnx_internal_onnx_onnx_proto_init() {
	if File_zonnx_internal_onnx_onnx_proto != nil {
		return
	}
	file_zonnx_internal_onnx_onnx_proto_msgTypes[7].OneofWrappers = []any{
		(*SimpleShardedDimProto_DimValue)(nil),
		(*SimpleShardedDimProto_DimParam)(nil),
	}
	file_zonnx_internal_onnx_onnx_proto_msgTypes[17].OneofWrappers = []any{
		(*TypeProto_TensorType)(nil),
		(*TypeProto_SequenceType)(nil),
		(*TypeProto_MapType)(nil),
		(*TypeProto_OptionalType)(nil),
		(*TypeProto_SparseTensorType)(nil),
	}
	file_zonnx_internal_onnx_onnx_proto_msgTypes[21].OneofWrappers = []any{
		(*TensorShapeProto_Dimension_DimValue)(nil),
		(*TensorShapeProto_Dimension_DimParam)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_zonnx_internal_onnx_onnx_proto_rawDesc), len(file_zonnx_internal_onnx_onnx_proto_rawDesc)),
			NumEnums:      5,
			NumMessages:   27,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_zonnx_internal_onnx_onnx_proto_goTypes,
		DependencyIndexes: file_zonnx_internal_onnx_onnx_proto_depIdxs,
		EnumInfos:         file_zonnx_internal_onnx_onnx_proto_enumTypes,
		MessageInfos:      file_zonnx_internal_onnx_onnx_proto_msgTypes,
	}.Build()
	File_zonnx_internal_onnx_onnx_proto = out.File
	file_zonnx_internal_onnx_onnx_proto_goTypes = nil
	file_zonnx_internal_onnx_onnx_proto_depIdxs = nil
}
